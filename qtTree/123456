
附件1：源程序的连续的前30页和连续的后30页：
一、源代码连续前30页
1.1 pyqtTree.py
# -*- coding: utf-8 -*-
from PyQt4 import QtCore, QtGui, uic
from PyQt4.QtGui import *
from PyQt4.QtCore import *
import os
from qimage2numpy import qpixmap2numpy
from pixels import Calc
import sqlite3
import win32api
from qttreeui import *
#qtCreatorFile = "qttree.ui" # Enter file here.
#Ui_MainWindow, QtBaseClass = uic.loadUiType(qtCreatorFile)
def dict_factory(cursor, row):
    d = {}
    for idx, col in enumerate(cursor.description):
        d[col[0]] = row[idx]
    return d
#QGraphics
class CustomPolygonItem(QGraphicsPolygonItem):
    def __init__(self, polygon):
        QGraphicsPolygonItem.__init__(self)
        self.setPolygon(polygon)
        pen = QPen()
        pen.setWidth(3)
    def scaleView(self, scaleFactor):
        self.scale(scaleFactor, scaleFactor)
class CustomLineItem(QGraphicsLineItem):
    def __init__(self):
        QGraphicsLineItem.__init__(self)
    def startDraw(self, e):
        self.setLine(QLineF(e.scenePos(), e.scenePos()))
    def drawing(self, e):
        newLine = QLineF(self.line().p1(), e.scenePos())
        self.setLine(newLine)
class CustomRectItem(QGraphicsRectItem):
    def __init__(self, w, h):
        QGraphicsRectItem.__init__(self)
        self.setRect(w/2, h/2, w/5, h/5)
        pen = QPen()
        pen.setWidth(3)
    '''
    def mousePressEvent(self, e):#*args, **kwargs):
        p1 = self.mapFromItem(self, QPointF(0, 0))
        p2 = self.mapToItem(self, QPointF(0, 0))
        p3 = self.mapFromScene(QPointF(0, 0))
        print 'item mapFromItem',p1.x(), p1.y()
        print 'item mapToItem', p2.x(), p2.y()
        print 'item mapFromScene', p3.x(), p3.y()
        #self.update()
        #pass
    '''
    def scaleView(self, scaleFactor):
        factor = self.matrix().scale(scaleFactor, scaleFactor).mapRect(QtCore.QRectF(0, 0, 1, 1)).width()
        if factor < 0.07 or factor > 100:
            return
        self.scale(scaleFactor, scaleFactor)
class CustomScence(QGraphicsScene):
    noShape, rect, polygon = range(3)
    def __init__(self):
        QGraphicsScene.__init__(self)
        self.shapeCase = self.noShape
        self.isFirstPoint = True
        self.pointList = None
        self.lineList = None
        self.objectPolygon = None
        self.np = None
        self.qpm = None
        self.clipImage = None
    def setShapeCase(self, n):
        self.shapeCase = n
    '''
    def setBackImagePath(self, path):
        self.path = path
    def drawBackground(self, painter, rectF):
        image = QImage(self.path)
        source = QRectF(0.0, 0.0, image.width(), image.height())
        painter.drawImage(rectF, image, source)
    '''
    def keyPressEvent(self, e):
        key = e.key()
        if key == Qt.Key_Backspace | key == Qt.Key_Delete:
            while self.selectedItems():
                self.removeItem(self.selectedItems()[0])
            self.isFirstPoint = True
            self.pointList = None
            self.lineList = None
        if key == QtCore.Qt.Key_PageDown:
            if self.selectedItems():
                self.selectedItems()[0].scaleView(1.2)
        elif key == QtCore.Qt.Key_PageUp:
            if self.selectedItems():
                self.selectedItems()[0].scaleView(1/1.2)
        else:
            QGraphicsScene.keyPressEvent(self,e)
    def mousePressEvent(self, e):
        if self.shapeCase == self.polygon:
            linePainter = CustomLineItem()
            self.currItem = linePainter
            self.addItem((self.currItem))
            if self.currItem != None:
                self.currItem.startDraw(e)
            #print "press", e.scenePos()
            if self.isFirstPoint:
                self.pointList = [e.scenePos()]
                self.lineList = [self.currItem]
                self.isFirstPoint = False
            else:
                self.pointList.append(e.scenePos())
                self.lineList.append(self.currItem)
        QGraphicsScene.mousePressEvent(self, e)
    def mouseMoveEvent(self, e):
        if self.shapeCase == self.polygon:
            if self.currItem != None:
                    self.currItem.drawing(e)
        QGraphicsScene.mouseMoveEvent(self, e)
    def isSamePoint(self, p1, p2, v):
        x = p1.x() - p2.x()
        y = p1.y() - p2.y()
        return x*x+y*y < v*v
    def clipPolygonObject(self):
        if self.objectPolygon is None:
            return
        objectRect = self.objectPolygon.boundingRect()
        map = self.qpm.copy(objectRect.topLeft().x(), objectRect.topLeft().y(), objectRect.bottomRight().x(), objectRect.bottomRight().y())
        polygonPath= QPainterPath()
        polygonPath.addPolygon(self.objectPolygon)
        polygonPath = polygonPath.translated(0-objectRect.topLeft().x(), 0-objectRect.topLeft().y())
        tempImage = QPixmap(objectRect.width(), objectRect.height())
        tempImage.fill(QColor(0, 0, 0))
        tempPaint = QPainter(tempImage)
        tempPaint.setClipping(True)
        tempPaint.setClipPath(polygonPath)
        tempPaint.drawPixmap(0,0, map)
        tempPaint.setClipping(False)
        tempPaint.end()
        self.clipImage = qpixmap2numpy(tempImage)
        #tempImage.save(QString(r"C:\Users\Administrator\Desktop\cutTree.jpg"))
    def mouseReleaseEvent(self, e):
        if self.shapeCase == self.polygon:
            #print "release", e.scenePos()
            if self.pointList is not None:
                if self.isSamePoint(e.scenePos(), self.pointList[0], 105) and len(self.pointList) > 2:
                    while self.lineList:
                        self.removeItem(self.lineList[0])
                        self.lineList = self.lineList[1:]
                    self.pointList.append(self.pointList[0])
                    self.objectPolygon = QPolygonF(self.pointList)
                    item = CustomPolygonItem(self.objectPolygon)
                    self.addItem(item)
                    item.setFlag(QGraphicsItem.ItemIsMovable)
                    item.setFlag(QGraphicsItem.ItemIsSelectable)
                    self.setShapeCase(self.noShape)
        QGraphicsScene.mouseReleaseEvent(self, e)
    def setTreePixmap(self, path):
        self.clear()
        self.shapeCase = self.noShape
        self.isFirstPoint = True
        self.pointList = None
        self.lineList = None
        self.objectPolygon = None
        self.np = None
        self.qpm = None
        self.clipImage = None
        item = None
        if path != "":
            self.qpm = QPixmap(path)
            item = self.addPixmap(self.qpm)
        return item
class MyApp(QMainWindow, Ui_qttree):
    def __init__(self, root):
        QMainWindow.__init__(self)
        super(MyApp, self).__init__()
        self.setupUi(self)
        self.root = root
        self.init_sqlite3()
        self.scene = CustomScence()
        self.graphicsView.setScene(self.scene)
        self.initMyUI()
        self.graphicsView.show()
    def initMyUI(self):
        self.createButtonConnect()
        self.treeTableUI()
        self.graphicsView.setAlignment(Qt.AlignLeft)
        self.graphicsView.setAlignment(Qt.AlignTop)
        self.graphicsView.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.graphicsView.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)

        self.imagePath = "image/timg.jpg"
        self.slotSetTreeImage()
        self.painterClickTimes = 0
    def init_sqlite3(self):
        self.conn = sqlite3.connect("%s/TreeHealth.db" % (self.root))
        self.conn.row_factory = dict_factory
        self.conn.text_factory = lambda x: unicode(x, "utf-8")
        self.cursor = self.conn.cursor()
    #treeTable
    def treeTableUI(self):
        self.createTreeTableActions()
        self.cursor.execute("SELECT * FROM treeTable")
        self.tree_table = self.cursor.fetchall()
        self.treeInfoRows = len(self.tree_table)
        self.treeInfoColumns = 5
        self.tableWidget_3.setRowCount(self.treeInfoRows)
        self.comboBox_5.clear()
        for row, treeRow in enumerate(self.tree_table):
            self.tableWidget_3.setItem(row, 0, QTableWidgetItem('%d'%treeRow['treeID']))
            self.tableWidget_3.setItem(row, 1, QTableWidgetItem(treeRow['species']))
            self.tableWidget_3.setItem(row, 2, QTableWidgetItem('%d'%treeRow['age']))
            self.tableWidget_3.setItem(row, 3, QTableWidgetItem(treeRow['place']))
            self.tableWidget_3.setItem(row, 4, QTableWidgetItem(treeRow['protectLevel']))
            self.comboBox_5.addItem('%d'%treeRow['treeID'])
        self.tableWidget_3.horizontalHeader().setResizeMode(QHeaderView.Stretch)
        self.tableWidget_3.setSelectionBehavior(QAbstractItemView.SelectRows)
        self.tableWidget_3.setSelectionMode(QAbstractItemView.SingleSelection)
    def treeTableAddRow(self):
        #self.tableWidget_3.insertRow(self.tableWidget_3, 1)
        self.treeInfoRows = self.treeInfoRows + 1
        self.tableWidget_3.setRowCount(self.treeInfoRows)
    def treeTableDelRow(self):
        self.treeInfoRows = self.treeInfoRows - 1
        rowIndex = self.tableWidget_3.currentRow()
        self.tableWidget_3.removeRow(rowIndex)
    def treeTableSave(self):
        self.cursor.execute("DELETE FROM treeTable")
        for i in range(self.treeInfoRows):
            self.cursor.execute(
                "insert into treeTable(treeID,species,age,place,protectLevel) values (?,?,?,?,?)",
                (unicode(self.tableWidget_3.item(i, 0).data(Qt.DisplayRole).toString()),
                 unicode(self.tableWidget_3.item(i, 1).data(Qt.DisplayRole).toString()),
                 unicode(self.tableWidget_3.item(i, 2).data(Qt.DisplayRole).toString()),
                 unicode(self.tableWidget_3.item(i, 3).data(Qt.DisplayRole).toString()),
                 unicode(self.tableWidget_3.item(i, 4).data(Qt.DisplayRole).toString())))
        self.conn.commit()
        self.treeTableUI()
    #右键菜单
    def contextMenuEvent(self, event):
        menu = QtGui.QMenu(self)
        menu.addAction(self.addRow)
        menu.addAction(self.delRow)
        menu.addAction(self.Save)
        menu.exec_(event.globalPos())
    def createTreeTableActions(self):
        self.addRow = QtGui.QAction(u"&添加行", self,
                                    shortcut=QtGui.QKeySequence.New,
                                    statusTip=u"树木信息添加行",
                                    triggered=self.treeTableAddRow)
        self.delRow = QtGui.QAction(u"&删除行", self,
                                    shortcut=QtGui.QKeySequence.Delete,
                                    statusTip=u"树木信息删除选中行",
                                    triggered=self.treeTableDelRow)
        self.Save = QtGui.QAction(u"&保存", self,
                                    shortcut=QtGui.QKeySequence.Save,
                                    statusTip=u"保存树木信息",
                                    triggered=self.treeTableSave)
    #all buttons of qgraphics
    noShape, rect, polygon = range(3)
    def createButtonConnect(self):
        self.pushButton_6.clicked.connect(self.slotAddPolygonItem)
        self.pushButton_4.clicked.connect(self.slotAddRectItem)
        self.toolButton_3.clicked.connect(self.slotOpenImageButton)
        self.pushButton_3.clicked.connect(self.slotCoreCalc)
        self.action_6.triggered.connect(self.testColorRange)
        self.action_7.triggered.connect(self.testParameters)
        self.c = Calc()
        for s in self.c.listFuntion:
            ss = self.c.dictFuntion2[s]
            self.comboBox_6.addItem(ss)
        #color range test
    def testParameters(self):
        command = "notepad.exe %s/parameters/pixels.ini" % self.root
        os.system(command)
    def testColorRange(self):
        self.c.testColor()
        if self.c.resultTestColor != None:
            self.textBrowser_6.setText(self.c.resultTestColor)
    def slotCoreCalc(self):
        self.statusBar().showMessage(u"修改函数参数，可打开当前目录下的parameters文件夹下的pixels.ini文档修改", 5000)
        if self.scene.clipImage is None:
            self.scene.clipPolygonObject()
        functionName = unicode(self.comboBox_6.currentText())
        functionName = self.c.dictFuntion1[functionName]
        self.c.resultTestColor = u""
        if self.scene.objectPolygon is not None:
            self.c.calculate(self.scene.clipImage, functionName)
        elif self.scene.qpm is not None:
            self.c.calculate(qpixmap2numpy(self.scene.qpm), functionName)
        else:
            self.statusBar().showMessage(u"图片未打开，无法诊断", 2000)
        str = u""
        if self.c.result != "" and self.c.resultTestColor != "":
            str = u"leaves pixels：{0},\nhealthy crown pixels：{1},\nrecommended levels：{2}".format(self.c.result[0], self.c.result[1], self.c.result[2])
            str = self.c.resultTestColor + str
        self.textBrowser_6.setText(str)
    def slotAddPolygonItem(self):
        self.painterClickTimes = self.painterClickTimes + 1
        if self.painterClickTimes % 2 == 1:
            self.setCursor(Qt.CrossCursor)
            self.scene.setShapeCase(self.polygon)
        else:
            self.setCursor(Qt.ArrowCursor)
            self.scene.setShapeCase(self.noShape)
    def slotOpenImageButton(self):
        s = QFileDialog.getOpenFileName(self, u"打开图片","/", "Image Files(*.png *.jpg *.bmp)")
        self.lineEdit.setText(s)
        self.slotSetTreeImage()
    def slotAddRectItem(self):
        self.scene.setShapeCase(self.rect)
        item = CustomRectItem(500, 500)
        self.scene.addItem(item)
        self.graphicsView.ensureVisible(item)
        item.setFlag(QGraphicsItem.ItemIsMovable)
        item.setFlag(QGraphicsItem.ItemIsSelectable)
    def slotSetTreeImage(self):
        s = unicode(self.lineEdit.text())
        if s != '':
            self.imagePath = s
        #item = self.scene.setTreePixmap(self.imagePath)
        item = self.scene.setTreePixmap(s)
        if item is not None:
            self.graphicsView.fitInView(item, Qt.KeepAspectRatio)
        #self.scene.setBackImagePath(self.imagePath)
if __name__ == "__main__":
    import sys
    if len(sys.argv) > 0:
        root_path = sys.argv[0]
        root_path = os.path.dirname(root_path)
    app = QtGui.QApplication(sys.argv)
    window = MyApp(root_path)
    window.show()
    sys.exit(app.exec_())
1.2 pixels.py
# -*- coding: utf-8 -*-
import numpy as np
import matplotlib
import FileDialog
from matplotlib import pyplot as plt
import math
import cv2
import os
import ConfigParser
import codecs
class Calc():
    listFuntion = [ 'leaf_colorRangeLevel', 'leaf_findGreenPixels', 'crownExcursion', 'leaf_hsvHist']
    dictFuntion1 = {u'树叶诊断（颜色直方图）':'leaf_colorRangeLevel', u'树叶诊断（RGB）':'leaf_findGreenPixels',u'偏冠诊断':'crownExcursion',u'绘制颜色直方图': 'leaf_hsvHist'}
    dictFuntion2 = {'leaf_colorRangeLevel':u'树叶诊断（颜色直方图）', 'leaf_findGreenPixels': u'树叶诊断（RGB）', 'crownExcursion': u'偏冠诊断', 'leaf_hsvHist':u'绘制颜色直方图'}
    def __init__(self):
        self.readConfigParameters()
        self.drawByHist = True
        self.resultTestColor = None
        self.result = None
        self.wrongString = u"No Wrong"
        self.spentTimeString = u"No Spenting Time"
    def readConfigParameters(self):
        #self.config = ConfigParser.ConfigParser()
        #self.config.read(r'./parameters/pixels.ini')
        self.config = ConfigParser.SafeConfigParser()
        with codecs.open(r'./parameters/pixels.ini', 'r', encoding='utf-8') as f:
            self.config.readfp(f)
        '''
        try:
            self.config = ConfigParser.SafeConfigParser()
            with codecs.open(r'./parameters/pixels.ini', 'r', encoding='utf-8') as f:
                self.config.readfp(f)
        except:
            return u"读配置文档错误"
        return u""
        '''
    def leaves(self, img):
        maxx = img.shape[0]
        maxy = img.shape[1]
        pixs = 0
        # print maxx, maxy
        for x in range(0, maxx):
            for y in range(0, maxy):
                if img[x, y, 1] > img[x, y, 0] and img[x, y, 1] > img[x, y, 2]:
                    #img[x, y] = [0, 255, 0]
                    pixs = pixs + 1
        return pixs
    def crown(self, img, backgroundValue=0):
        imgray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        maxx = img.shape[0]
        maxy = img.shape[1]
        pixs = 0
        # print maxx, maxy
        for x in range(0, maxx):
            for y in range(0, maxy):
                if imgray[x, y] != backgroundValue:
                    pixs = pixs + 1
        return pixs
    def grade(self, nu, de, totalv, n):
        curv = float(nu) / de
        mean = float(totalv) / n
        rank = n - math.floor(curv / mean)
        return rank
    def leaf_findGreenPixels(self):
        plt.subplot(111)
        plt.imshow(self.img)
        self.im2 = self.img
        leavesPixels = self.leaves(self.im2)
        crownPixels = self.crown(self.img)
        rank = self.grade(leavesPixels, crownPixels, 1, 5)
        plt.show()
        return leavesPixels, crownPixels, rank
    def crownExcursion(self):
        pass
    def leaf_hsvHist(self, isShowImage=False):
        from color_histogram.core.hist_1d import Hist1D
        import matplotlib.pyplot as plt
        from time import clock
        bgr = self.img
        rgb = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)
        try:
            num_bins = self.config.getint("leaf_hsvHist", "num_bins")
        except ConfigParser.Error:
            #print u"Error: 读不到该值"
            self.wrongString = u"Error: 读不到该值"
            num_bins = 16
        self.num_bins = num_bins
        start = clock()
        num_pixels = (self.img.shape[0]*self.img.shape[1])/10
        hist1D = Hist1D(rgb, num_bins=num_bins, color_space='hsv', channel=0, num_pixels=num_pixels, alpha=0.01)
        self.calc_hist_bins = hist1D.calc_hist_bins
        if isShowImage and self.drawByHist:
            fig = plt.figure()
            axx = fig.add_subplot(121)
            axx.imshow(rgb)
            ax = fig.add_subplot(122)
            hist1D.plot(ax)
            plt.show()
        elif self.drawByHist != True:
            self.rgb = rgb
            self.hist1D = hist1D
        finished = clock()
        #print " Spend Time: %f" % (finished - start)
        self.spentTimeString = u" Spend Time: %f" % (finished - start)
    def leaf_colorRangeLevel(self):
        self.leaf_hsvHist()
        try:
            colorRangeMin = self.config.getint("leaf_colorRangeLevel", "colorRangeMin")
            colorRangeMax = self.config.getint("leaf_colorRangeLevel", "colorRangeMax")
            weights = self.config.get("leaf_colorRangeLevel", "weights")
        except ConfigParser.Error:
            #print u"Error: leaf_colorRangeLevel 读不到值"
            self.wrongString = u"Error: leaf_colorRangeLevel 读不到值"
            colorRangeMin = 3
            colorRangeMax = 7
            weights = "default"
        if weights == "default":
            '''
            mean = 1.0/(colorRangeMax-colorRangeMin)
            weightlist = np.arange(1, colorRangeMax-colorRangeMin+1, dtype=np.float32)
            weightlist = weightlist * mean
          '''
            weightlist = np.ones(colorRangeMax-colorRangeMin+1)
        else:
            weightlist = weights.split(',')
            l = []
            for s in weightlist:
                l.append(int(s))
            weightlist = np.array(l)
        greenlist = []
        for i in range(colorRangeMin, colorRangeMax+1):
            greenlist.append(self.calc_hist_bins[i])
        greenlist = np.array(greenlist)
        if len(greenlist) != len(weightlist):
            #print "权重个数和树叶指标数不一致"
            self.wrongString = u"权重个数和树叶指标数不一致"
            return
        leaves_sum = np.sum(greenlist * weightlist)
        crown_sum = np.sum(self.calc_hist_bins) - self.calc_hist_bins[0] - self.calc_hist_bins[self.num_bins - 1]
        rank = self.grade(leaves_sum, crown_sum, 1, 5)
        try:
            ranges = self.config.get("testColor", "ranges")
            names = self.config.get("testColor", "names")
        except ConfigParser.Error:
            #print u"Error:testColor 读不到值"
            self.wrongString = u"Error:testColor 读不到值"
            return
        rangelist = ranges.split(',')
        namelist = names.split(',')
        l = []
        for s in rangelist:
            l.append(int(s))
        rangelist = np.array(l)
        n = len(rangelist) / 2
        resultTestColor = u''
        sum = crown_sum
        for i in range(0, n):
            min = rangelist[2 * i]
            max = rangelist[2 * i + 1]
            csum = 0.0
            for x in range(min, max + 1):
                csum += self.calc_hist_bins[x]
            ratio = csum / sum
            str = "{0} leaves {1}-{2}\nratio: {3}%\n".format(namelist[i], min, max, round(ratio * 100, 2))
            resultTestColor = resultTestColor + str
        self.resultTestColor = resultTestColor
        return leaves_sum, crown_sum, rank
    def testColor(self):
        try:
            imagePath = self.config.get("testColor", "imagePath")
            ranges = self.config.get("testColor", "ranges")
            names = self.config.get("testColor", "names")
        except ConfigParser.Error:
            #print u"Error:testColor 读不到值"
            self.wrongString = u"Error:testColor 读不到值"
        rangelist = ranges.split(',')
        namelist = names.split(',')
        l = []
        for s in rangelist:
            l.append(int(s))
        rangelist = np.array(l)
        self.drawByHist = False
        for src in os.listdir(imagePath):
            if 'bmp' not in src:
                continue
            src = imagePath + '\\' + src
            self.calculate(imgPath=src, function=self.listFuntion[3], img=None)
            n = len(rangelist)/2
            resultTestColor = u''
            sum = np.sum(self.calc_hist_bins)-self.calc_hist_bins[0]-self.calc_hist_bins[self.num_bins-1]
            for i in range(0, n):
                min = rangelist[2*i]
                max = rangelist[2*i+1]
                csum = 0.0
                for x in range(min, max+1):
                    csum += self.calc_hist_bins[x]
                ratio = csum / sum
                str = "{0} leaves {1}-{2}\nratio: {3}%\n".format(namelist[i], min, max, round(ratio*100, 2))
                resultTestColor = resultTestColor + str
            fig = plt.figure()
            axx = fig.add_subplot(121)
            axx.imshow(self.rgb)
            ax = fig.add_subplot(122)
            ax.text(170, 0.8, resultTestColor)
            self.hist1D.plot(ax)
            plt.show()
    def calculate(self, img, function, imgPath=None):
        if imgPath == None:
            self.img = img
        else:
            self.img = cv2.imread(imgPath, cv2.IMREAD_COLOR)
        #if the image is too big, the "MemoryError" will be taken place
        if self.img.shape[0] > 2000 or self.img.shape[1] > 2000:
            self.imgOriginal = self.img.copy()
            size = (int(self.img.shape[0] * 0.05), int(self.img.shape[1] * 0.05))
            self.img = cv2.resize(self.imgOriginal, size, interpolation=cv2.INTER_AREA)
        if function == 'leaf_hsvHist' or function == self.listFuntion[3]:
            self.leaf_hsvHist(True)
        elif function == 'leaf_findGreenPixels' or function == self.listFuntion[1]:
            self.result = self.leaf_findGreenPixels()
        elif function == 'crownExcursion' or function == self.listFuntion[2]:
            self.crownExcursion()
        elif function == 'leaf_colorRangeLevel' or function == self.listFuntion[0]:
            self.result = self.leaf_colorRangeLevel()
        else:
            pass
    def get_original_image(self):
        return self.img
    def get_modified_image(self):
        return self.im2
'''
source = r'D:\wei\1learning\IT\course\grade4\graduationProject\data\img\20170407\leaf'
#source = r'D:\wei\1learning\IT\course\grade4\graduationProject\data\img\result'
for src in os.listdir(source):
    if 'bmp' not in src :
        continue
    src = source +'\\'+src
    c = Calc()
    c.calculate(imgPath=src, function=c.listFuntion[3], img=None)
'''
1.3 qttreeui.py
# -*- coding: utf-8 -*-
# Form implementation generated from reading ui file 'D:\wei\weiProgramme\projects\graduation\qtTree\qttree.ui'
#
# Created by: PyQt4 UI code generator 4.11.4
#
# WARNING! All changes made in this file will be lost!
from PyQt4 import QtCore, QtGui
try:
    _fromUtf8 = QtCore.QString.fromUtf8
except AttributeError:
    def _fromUtf8(s):
        return s
try:
    _encoding = QtGui.QApplication.UnicodeUTF8
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig, _encoding)
except AttributeError:
    def _translate(context, text, disambig):
        return QtGui.QApplication.translate(context, text, disambig)
class Ui_qttree(object):
    def setupUi(self, qttree):
        qttree.setObjectName(_fromUtf8("qttree"))
        qttree.resize(1002, 573)
        sizePolicy = QtGui.QSizePolicy(QtGui.QSizePolicy.MinimumExpanding, QtGui.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(qttree.sizePolicy().hasHeightForWidth())
        qttree.setSizePolicy(sizePolicy)
        self.centralwidget = QtGui.QWidget(qttree)
        self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
        self.horizontalLayoutWidget_5 = QtGui.QWidget(self.centralwidget)
        self.horizontalLayoutWidget_5.setGeometry(QtCore.QRect(9, 7, 991, 521))
        self.horizontalLayoutWidget_5.setObjectName(_fromUtf8("horizontalLayoutWidget_5"))
        self.horizontalLayout_6 = QtGui.QHBoxLayout(self.horizontalLayoutWidget_5)
        self.horizontalLayout_6.setSizeConstraint(QtGui.QLayout.SetNoConstraint)
        self.horizontalLayout_6.setObjectName(_fromUtf8("horizontalLayout_6"))
        self.verticalLayout_3 = QtGui.QVBoxLayout()
        self.verticalLayout_3.setObjectName(_fromUtf8("verticalLayout_3"))
        self.label_13 = QtGui.QLabel(self.horizontalLayoutWidget_5)
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Wide Latin"))
        font.setPointSize(10)
        font.setBold(True)
        font.setItalic(False)
        font.setUnderline(False)
        font.setWeight(75)
        font.setStrikeOut(False)
        font.setKerning(True)
        self.label_13.setFont(font)
        self.label_13.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.label_13.setObjectName(_fromUtf8("label_13"))
        self.verticalLayout_3.addWidget(self.label_13)
        self.tableWidget_3 = QtGui.QTableWidget(self.horizontalLayoutWidget_5)
        self.tableWidget_3.setObjectName(_fromUtf8("tableWidget_3"))
        self.tableWidget_3.setColumnCount(5)
        self.tableWidget_3.setRowCount(0)
        item = QtGui.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(0, item)
        item = QtGui.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(1, item)
        item = QtGui.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(2, item)
        item = QtGui.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(3, item)
        item = QtGui.QTableWidgetItem()
        self.tableWidget_3.setHorizontalHeaderItem(4, item)
        self.verticalLayout_3.addWidget(self.tableWidget_3)
        self.label_14 = QtGui.QLabel(self.horizontalLayoutWidget_5)
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Wide Latin"))
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label_14.setFont(font)
        self.label_14.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.label_14.setObjectName(_fromUtf8("label_14"))
        self.verticalLayout_3.addWidget(self.label_14)
        self.horizontalLayout_10 = QtGui.QHBoxLayout()
        self.horizontalLayout_10.setObjectName(_fromUtf8("horizontalLayout_10"))
        self.label_15 = QtGui.QLabel(self.horizontalLayoutWidget_5)
        self.label_15.setObjectName(_fromUtf8("label_15"))
        self.horizontalLayout_10.addWidget(self.label_15)
        self.lineEdit = QtGui.QLineEdit(self.horizontalLayoutWidget_5)
        self.lineEdit.setObjectName(_fromUtf8("lineEdit"))
        self.horizontalLayout_10.addWidget(self.lineEdit)
        self.toolButton_3 = QtGui.QToolButton(self.horizontalLayoutWidget_5)
        self.toolButton_3.setObjectName(_fromUtf8("toolButton_3"))
        self.horizontalLayout_10.addWidget(self.toolButton_3)
        self.verticalLayout_3.addLayout(self.horizontalLayout_10)
        self.horizontalLayout_11 = QtGui.QHBoxLayout()
        self.horizontalLayout_11.setObjectName(_fromUtf8("horizontalLayout_11"))
        self.label_16 = QtGui.QLabel(self.horizontalLayoutWidget_5)
        self.label_16.setFocusPolicy(QtCore.Qt.TabFocus)
        self.label_16.setObjectName(_fromUtf8("label_16"))
        self.horizontalLayout_11.addWidget(self.label_16)
        self.comboBox_5 = QtGui.QComboBox(self.horizontalLayoutWidget_5)
        self.comboBox_5.setObjectName(_fromUtf8("comboBox_5"))
        self.horizontalLayout_11.addWidget(self.comboBox_5)
        self.horizontalLayout_11.setStretch(1, 1)
        self.verticalLayout_3.addLayout(self.horizontalLayout_11)
        self.horizontalLayout_12 = QtGui.QHBoxLayout()
        self.horizontalLayout_12.setObjectName(_fromUtf8("horizontalLayout_12"))
        self.label_17 = QtGui.QLabel(self.horizontalLayoutWidget_5)
        self.label_17.setObjectName(_fromUtf8("label_17"))
        self.horizontalLayout_12.addWidget(self.label_17)
        self.comboBox_6 = QtGui.QComboBox(self.horizontalLayoutWidget_5)
        self.comboBox_6.setObjectName(_fromUtf8("comboBox_6"))
        self.horizontalLayout_12.addWidget(self.comboBox_6)
        self.horizontalLayout_12.setStretch(1, 1)
        self.verticalLayout_3.addLayout(self.horizontalLayout_12)
        self.horizontalLayout_13 = QtGui.QHBoxLayout()
        self.horizontalLayout_13.setObjectName(_fromUtf8("horizontalLayout_13"))
        spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
        self.horizontalLayout_13.addItem(spacerItem)
        self.pushButton_3 = QtGui.QPushButton(self.horizontalLayoutWidget_5)
        self.pushButton_3.setObjectName(_fromUtf8("pushButton_3"))
        self.horizontalLayout_13.addWidget(self.pushButton_3)
        self.verticalLayout_3.addLayout(self.horizontalLayout_13)
        self.line_3 = QtGui.QFrame(self.horizontalLayoutWidget_5)
        self.line_3.setFrameShape(QtGui.QFrame.VLine)
        self.line_3.setFrameShadow(QtGui.QFrame.Sunken)
        self.line_3.setObjectName(_fromUtf8("line_3"))
        self.verticalLayout_3.addWidget(self.line_3)
        self.label_18 = QtGui.QLabel(self.horizontalLayoutWidget_5)
        font = QtGui.QFont()
        font.setFamily(_fromUtf8("Wide Latin"))
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.label_18.setFont(font)
        self.label_18.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.label_18.setObjectName(_fromUtf8("label_18"))
        self.verticalLayout_3.addWidget(self.label_18)
        self.textBrowser_6 = QtGui.QTextBrowser(self.horizontalLayoutWidget_5)
        self.textBrowser_6.setObjectName(_fromUtf8("textBrowser_6"))
        self.verticalLayout_3.addWidget(self.textBrowser_6)
        self.horizontalLayout_6.addLayout(self.verticalLayout_3)
        self.verticalLayout_4 = QtGui.QVBoxLayout()
        self.verticalLayout_4.setObjectName(_fromUtf8("verticalLayout_4"))
        self.graphicsView = QtGui.QGraphicsView(self.horizontalLayoutWidget_5)
        self.graphicsView.setEnabled(True)
        brush = QtGui.QBrush(QtGui.QColor(0, 0, 0))
        brush.setStyle(QtCore.Qt.NoBrush)
        self.graphicsView.setForegroundBrush(brush)
        self.graphicsView.setObjectName(_fromUtf8("graphicsView"))
        self.verticalLayout_4.addWidget(self.graphicsView)
        self.horizontalLayout_14 = QtGui.QHBoxLayout()
        self.horizontalLayout_14.setObjectName(_fromUtf8("horizontalLayout_14"))
        self.pushButton_6 = QtGui.QPushButton(self.horizontalLayoutWidget_5)
        self.pushButton_6.setObjectName(_fromUtf8("pushButton_6"))
        self.horizontalLayout_14.addWidget(self.pushButton_6)
        self.pushButton_4 = QtGui.QPushButton(self.horizontalLayoutWidget_5)
        self.pushButton_4.setText(_fromUtf8(""))
        self.pushButton_4.setObjectName(_fromUtf8("pushButton_4"))
        self.horizontalLayout_14.addWidget(self.pushButton_4)
        self.pushButton_8 = QtGui.QPushButton(self.horizontalLayoutWidget_5)
        self.pushButton_8.setText(_fromUtf8(""))
        self.pushButton_8.setObjectName(_fromUtf8("pushButton_8"))
        self.horizontalLayout_14.addWidget(self.pushButton_8)
        self.pushButton_7 = QtGui.QPushButton(self.horizontalLayoutWidget_5)
        self.pushButton_7.setText(_fromUtf8(""))
        self.pushButton_7.setObjectName(_fromUtf8("pushButton_7"))
        self.horizontalLayout_14.addWidget(self.pushButton_7)
        self.commandLinkButton = QtGui.QCommandLinkButton(self.horizontalLayoutWidget_5)
        self.commandLinkButton.setObjectName(_fromUtf8("commandLinkButton"))
        self.horizontalLayout_14.addWidget(self.commandLinkButton)
        self.verticalLayout_4.addLayout(self.horizontalLayout_14)
        self.horizontalLayout_6.addLayout(self.verticalLayout_4)
        self.horizontalLayout_6.setStretch(0, 1)
        self.horizontalLayout_6.setStretch(1, 2)
        qttree.setCentralWidget(self.centralwidget)
        self.statusbar = QtGui.QStatusBar(qttree)
        self.statusbar.setObjectName(_fromUtf8("statusbar"))
        qttree.setStatusBar(self.statusbar)
        self.menuBar = QtGui.QMenuBar(qttree)
        self.menuBar.setGeometry(QtCore.QRect(0, 0, 1002, 23))
        self.menuBar.setObjectName(_fromUtf8("menuBar"))
        self.menu = QtGui.QMenu(self.menuBar)
        self.menu.setObjectName(_fromUtf8("menu"))
        self.menu_2 = QtGui.QMenu(self.menuBar)
        self.menu_2.setObjectName(_fromUtf8("menu_2"))
        self.menu_3 = QtGui.QMenu(self.menuBar)
        self.menu_3.setObjectName(_fromUtf8("menu_3"))
        qttree.setMenuBar(self.menuBar)
        self.action = QtGui.QAction(qttree)
        self.action.setObjectName(_fromUtf8("action"))
        self.action_2 = QtGui.QAction(qttree)
        self.action_2.setObjectName(_fromUtf8("action_2"))
        self.action_3 = QtGui.QAction(qttree)
        self.action_3.setObjectName(_fromUtf8("action_3"))
        self.action_Ctrl_S = QtGui.QAction(qttree)
        self.action_Ctrl_S.setObjectName(_fromUtf8("action_Ctrl_S"))
        self.action_4 = QtGui.QAction(qttree)
        self.action_4.setObjectName(_fromUtf8("action_4"))
        self.action_5 = QtGui.QAction(qttree)
        self.action_5.setObjectName(_fromUtf8("action_5"))
        self.action_6 = QtGui.QAction(qttree)
        self.action_6.setObjectName(_fromUtf8("action_6"))
        self.action_7 = QtGui.QAction(qttree)
        self.action_7.setObjectName(_fromUtf8("action_7"))
        self.menu.addAction(self.action_3)
        self.menu_2.addAction(self.action_6)
        self.menu_2.addAction(self.action_7)
        self.menu_3.addAction(self.action_4)
        self.menuBar.addAction(self.menu.menuAction())
        self.menuBar.addAction(self.menu_2.menuAction())
        self.menuBar.addAction(self.menu_3.menuAction())
        self.retranslateUi(qttree)
        QtCore.QMetaObject.connectSlotsByName(qttree)
    def retranslateUi(self, qttree):
        qttree.setWindowTitle(_translate("qttree", "Tree Health", None))
        self.label_13.setText(_translate("qttree", "树木信息--------------------------------------", None))
        item = self.tableWidget_3.horizontalHeaderItem(0)
        item.setText(_translate("qttree", "树木编号", None))
        item = self.tableWidget_3.horizontalHeaderItem(1)
        item.setText(_translate("qttree", "树木种类", None))
        item = self.tableWidget_3.horizontalHeaderItem(2)
        item.setText(_translate("qttree", "年龄", None))
        item = self.tableWidget_3.horizontalHeaderItem(3)
        item.setText(_translate("qttree", "产地", None))
        item = self.tableWidget_3.horizontalHeaderItem(4)
        item.setText(_translate("qttree", "保护等级", None))
        self.label_14.setText(_translate("qttree", "图片信息--------------------------------------", None))
        self.label_15.setText(_translate("qttree", "图片位置", None))
        self.toolButton_3.setText(_translate("qttree", "...", None))
        self.label_16.setText(_translate("qttree", "树木编号", None))
        self.label_17.setText(_translate("qttree", "诊断内容", None))
        self.pushButton_3.setText(_translate("qttree", "开始诊断", None))
        self.label_18.setText(_translate("qttree", "诊断结果--------------------------------------", None))
        self.pushButton_6.setText(_translate("qttree", "画笔", None))
        self.commandLinkButton.setText(_translate("qttree", "清除所有(Ctrl+l)", None))
        self.menu.setTitle(_translate("qttree", "文件", None))
        self.menu_2.setTitle(_translate("qttree", "操作", None))
        self.menu_3.setTitle(_translate("qttree", "帮助", None))
        self.action.setText(_translate("qttree", "设置", None))
        self.action_2.setText(_translate("qttree", "退出", None))
        self.action_3.setText(_translate("qttree", "退出", None))
        self.action_Ctrl_S.setText(_translate("qttree", "保存(Ctrl+S)", None))
        self.action_4.setText(_translate("qttree", "关于", None))
        self.action_5.setText(_translate("qttree", "测试", None))
        self.action_6.setText(_translate("qttree", "训练", None))
        self.action_7.setText(_translate("qttree", "诊断", None))
1.4 qimage2numpy
from PyQt4.QtGui import *
import numpy
def qimage2numpy(qimage, dtype = 'array'):
    """Convert QImage to numpy.ndarray.  The dtype defaults to uint8
    for QImage.Format_Indexed8 or `bgra_dtype` (i.e. a record array)
    for 32bit color images.  You can pass a different dtype to use, or
    'array' to get a 3D uint8 array for color images."""
    result_shape = (qimage.height(), qimage.width())
    temp_shape = (qimage.height(),
                  qimage.bytesPerLine() * 8 / qimage.depth())
    if qimage.format() in (QImage.Format_ARGB32_Premultiplied,
                           QImage.Format_ARGB32,
                           QImage.Format_RGB32):
        if dtype == 'rec':
            dtype = numpy.bgra_dtype
        elif dtype == 'array':
            dtype = numpy.uint8
            result_shape += (4, )
            temp_shape += (4, )
    elif qimage.format() == QImage.Format_Indexed8:
        dtype = numpy.uint8
    else:
        raise ValueError("qimage2numpy only supports 32bit and 8bit images")
    # FIXME: raise error if alignment does not match
    buf = qimage.bits().asstring(qimage.numBytes())
    result = numpy.frombuffer(buf, dtype).reshape(temp_shape)
    if result_shape != temp_shape:
        result = result[:,:result_shape[1]]
    if qimage.format() == QImage.Format_RGB32 and dtype == numpy.uint8:
        result = result[...,:3]
    return result
def qpixmap2numpy(inPixmap, dtype = 'array'):
    return qimage2numpy(inPixmap.toImage(), dtype)
1.5 color_pixels
# -*- coding: utf-8 -*-
## @package color_histogram.core.color_pixels
#
#  Simple color pixel class.
#
#  @author      tody
#  @date        2015/08/28
import numpy as np
from color_histogram.cv.image import to32F, rgb2Lab, rgb2hsv, gray2rgb
## Implementation of color pixels.
#
#  input image is automatically converted into np.float32 format.
class ColorPixels:
    ## Constructor
    #  @param image          input image.
    #  @param num_pixels     target number of pixels from the image.
    def __init__(self, image, num_pixels=1000):
        self._image = to32F(image)
        self._num_pixels = num_pixels
        self._rgb_pixels = None
        self._Lab = None
        self._hsv = None
    ## RGB pixels.
    def rgb(self):
        if self._rgb_pixels is None:
            self._rgb_pixels = self.pixels("rgb")
        return self._rgb_pixels
    ## Lab pixels.
    def Lab(self):
        if self._Lab is None:
            self._Lab = self.pixels("Lab")
        return self._Lab
    ## HSV pixels.
    def hsv(self):
        if self._hsv is None:
            self._hsv = self.pixels("hsv")
        return self._hsv
    ## Pixels of the given color space.
    def pixels(self, color_space="rgb"):
        image = np.array(self._image)
        if color_space == "rgb":
            if _isGray(image):
                image = gray2rgb(image)
        if color_space == "Lab":
            image = rgb2Lab(self._image)
        if color_space == "hsv":
            image = rgb2hsv(self._image)
        return self._image2pixels(image)
    def _image2pixels(self, image):
        if _isGray(image):
            h, w = image.shape
            step = h * w / self._num_pixels
            return image.reshape((h * w))[::step]
        h, w, cs = image.shape
        step = h * w / self._num_pixels
        return image.reshape((-1, cs))[::step]
def _isGray(image):
return len(image.shape) == 2
1.6 hist_1d.py
# -*- coding: utf-8 -*-
## @package color_histogram.core.hist_1d
#
#  Implementation of 1D color histograms.
#  @author      tody
#  @date        2015/08/29
import numpy as np
from color_histogram.core.color_pixels import ColorPixels
from color_histogram.core.hist_common import colorCoordinates, colorDensities, rgbColors, clipLowDensity, range2ticks
## Implementation of 1D color histograms.
class Hist1D:
    ## Constructor
    #  @param image          input image.
    #  @param num_bins       target number of histogram bins.
    #  @param alpha          low density clip.
    #  @param color_space    target color space. 'rgb' or 'Lab' or 'hsv'.
    #  @param channel        target color channel. 0 with 'Lab' = L channel.
    def __init__(self, image, num_bins=16, alpha=0.1, color_space='Lab', channel=0, num_pixels=1000):
        self._computeTargetPixels(image, color_space, channel, num_pixels)
        self._num_bins = num_bins
        self._alpha = alpha
        self._color_space = color_space
        self._channel = channel
        self._computeColorRange()
        self._computeHistogram()
        self._plotter = Hist1DPlot(self)
    ## Plot histogram.
    def plot(self, ax):
        self._plotter.plot(ax)
    def numBins(self):
        return self._num_bins
    def colorSpace(self):
        return self._color_space
    def channel(self):
        return self._channel
    def colorIDs(self):
        color_ids = np.where(self._histPositive())
        return color_ids
    def colorCoordinates(self):
        color_ids = self.colorIDs()
        num_bins = self._num_bins
        color_range = self._color_range
        return colorCoordinates(color_ids, num_bins, color_range)
    def colorDensities(self):
        return colorDensities(self._hist_bins)
    def rgbColors(self):
        return rgbColors(self._hist_bins, self._color_bins)
    def colorRange(self):
        return self._color_range
    def _computeTargetPixels(self, image, color_space, channel, num_pixels):
        color_pixels = ColorPixels(image, num_pixels)
        self._pixels = color_pixels.pixels(color_space)[:, channel]
        self._rgb_pixels = color_pixels.rgb()
    def _computeColorRange(self):
        pixels = self._pixels
        c_min = np.min(pixels)
        c_max = np.max(pixels)
        self._color_range = [c_min, c_max]
    def _computeHistogram(self):
        pixels = self._pixels
        num_bins = self._num_bins
        c_min, c_max = self._color_range
        hist_bins = np.zeros((num_bins), dtype=np.float32)
        color_bins = np.zeros((num_bins, 3), dtype=np.float32)
        color_ids = (num_bins - 1) * (pixels - c_min) / (c_max - c_min)
        color_ids = np.int32(color_ids)
        for pi, color_id in enumerate(color_ids):
            hist_bins[color_id] += 1
            color_bins[color_id] += self._rgb_pixels[pi]
        self.calc_hist_bins = np.copy(hist_bins)
        self._hist_bins = hist_bins
        hist_positive = self._hist_bins > 0.0
        for ci in xrange(3):
            color_bins[hist_positive, ci] /= self._hist_bins[hist_positive]
        self._color_bins = color_bins
        self._clipLowDensity()
    def _clipLowDensity(self):
        clipLowDensity(self._hist_bins, self._color_bins, self._alpha)
    def _histPositive(self):
        return self._hist_bins > 0.0
## 1D color histogram plotter.
class Hist1DPlot:
    ## Constructor.
    #  @param hist1D histogram for plotting.
    def __init__(self, hist1D):
        self._hist1D = hist1D
    def plot(self, ax):
        color_samples = self._hist1D.colorCoordinates()
        color_densities = self._hist1D.colorDensities()
        colors = self._hist1D.rgbColors()
        color_range = self._hist1D.colorRange()
        width = (color_range[1] - color_range[0]) / float(self._hist1D.numBins())
        ax.bar(color_samples, color_densities, width=width, color=colors)
        self._axisSetting(ax)
    def _range2lims(self, tick_range):
        unit = 0.1 * (tick_range[:, 1] - tick_range[:, 0])
        lim = np.array(tick_range)
        lim[0, 0] += -unit[0]
        lim[0, 1] += unit[0]
        lim[1, 1] += unit[1]
        return lim[0], lim[1]
    def _axisSetting(self, ax):
        color_space = self._hist1D.colorSpace()
        channel = self._hist1D.channel()
        color_space = color_space+'('+color_space[channel]+')'
        ax.set_xlabel(color_space)
        ax.set_ylabel("Density")
        color_range = self._hist1D.colorRange()
        tick_range = np.array([color_range, [0.0, 1.0]])
        xticks, yticks = range2ticks(tick_range)
        ax.set_xticks(xticks)
        ax.set_yticks(yticks)
        xlim, ylim = self._range2lims(tick_range)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
1.7 hist_common.py
# -*- coding: utf-8 -*-
## @package color_histogram.core.hist_common
#
#  Common color histogram functions for 1D, 2D, 3D.
#  @author      tody
#  @date        2015/08/29
import numpy as np
def colorCoordinates(color_ids, num_bins, color_range):
    color_ids = np.array(color_ids).T
    c_min, c_max = color_range
    color_coordinates = c_min + (color_ids * (c_max - c_min)) / float(num_bins - 1.0)
    return color_coordinates
def colorDensities(hist_bins):
    hist_positive = hist_bins > 0.0
    color_densities = np.float32(hist_bins[hist_positive])
    density_max = np.max(color_densities)
    color_densities = color_densities / density_max
    return color_densities
def rgbColors(hist_bins, color_bins):
    hist_positive = hist_bins > 0.0
    colors = color_bins[hist_positive, :]
    colors = np.clip(colors, 0.0, 1.0)
    return colors
def clipLowDensity(hist_bins, color_bins, alpha):
    density_mean = np.mean(hist_bins)
    low_density = hist_bins < density_mean * alpha
    hist_bins[low_density] = 0.0
    for ci in xrange(3):
        color_bins[low_density, ci] = 0.0
def densitySizes(color_densities, density_size_range):
    density_size_min, density_size_max = density_size_range
    density_size_factor = density_size_max / density_size_min
    density_sizes = density_size_min * np.power(density_size_factor, color_densities)
    return density_sizes
def range2ticks(tick_range, decimals=1):
    ticks = np.around(tick_range, decimals=decimals)
    ticks[ticks > 10] = np.rint(ticks[ticks > 10])
    return ticks
def range2lims(tick_range):
    unit = 0.1 * (tick_range[:, 1] - tick_range[:, 0])
    lim = np.array(tick_range)
    lim[:, 0] += -unit
lim[:, 1] += unit
return lim
二、源代码连续后30页
2.1 image.py
# -*- coding: utf-8 -*-
## @package color_histogram.cv.image
#
#  OpenCV image functions.
#  @author      tody
#  @date        2015/07/30

import numpy as np
import cv2

## Convert image into uint8 type.
def to8U(img):
    if img.dtype == np.uint8:
        return img
    return np.clip(np.uint8(255.0 * img), 0, 255)

## Convert image into float32 type.
def to32F(img):
    if img.dtype == np.float32:
        return img
    return (1.0 / 255.0) * np.float32(img)

## RGB channels of the image.
def rgb(img):
    if len(img.shape) == 2:
        h, w = img.shape
        img_rgb = np.zeros((h, w, 3), dtype=img.dtype)
        for ci in range(3):
            img_rgb[:, :, ci] = img
        return img_rgb
    h, w, cs = img.shape
    if cs == 3:
        return img
    img_rgb = np.zeros((h, w, 3), dtype=img.dtype)
    cs = min(3, cs)
    for ci in range(cs):
        img_rgb[:, :, ci] = img[:, :, ci]
    return img_rgb

## Alpha channel of the image.
def alpha(img):
    if len(img.shape) == 2:
        return None
    cs = img.shape[2]
    if cs != 4:
        return None
    return img[:, :, 3]

## Set alpha for the image.
def setAlpha(img, a):
    h = img.shape[0]
    w = img.shape[1]
    img_rgb = None
    if len(img.shape) == 2:
        img_rgb = gray2rgb(img)
    else:
        img_rgb = img
    img_rgba = np.zeros((h, w, 4), dtype=img.dtype)
    img_rgba[:, :, :3] = img_rgb
    img_rgba[:, :, 3] = a
    return img_rgba

## RGB to Gray.
def rgb2gray(img):
    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    return gray

## Gray to RGB.
def gray2rgb(img):
    gray = cv2.cvtColor(img, cv2.COLOR_GRAY2RGB)
    return gray

## Gray to RGBA.
def gray2rgba(img):
    gray = cv2.cvtColor(img, cv2.COLOR_GRAY2RGBA)
    return gray

## BGR to RGB.
def bgr2rgb(img):
    rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
    return rgb

## BGRA to RGBA.
def bgra2rgba(img):
    a = alpha(img)
    rgba = cv2.cvtColor(img, cv2.COLOR_BGRA2RGBA)
    if a is not None:
        rgba[:, :, 3] = a
    return rgba

## RGBA to BGRA.
def rgba2bgra(img):
    a = alpha(img)
    bgra = cv2.cvtColor(img, cv2.COLOR_RGBA2BGRA)
    bgra[:, :, 3] = a
    return bgra

## RGB to BGR.
def rgb2bgr(img):
    bgr = cv2.cvtColor(img, cv2.COLOR_RGB2BGR)
    return bgr

## RGB to Lab.
def rgb2Lab(img):
    img_rgb = rgb(img)
    Lab = cv2.cvtColor(img_rgb, cv2.COLOR_RGB2LAB)
    return Lab

## Lab to RGB.
def Lab2rgb(img):
    rgb = cv2.cvtColor(img, cv2.COLOR_LAB2RGB)
    return rgb

def rgb2hsv(img):
    img_rgb = rgb(img)
    return cv2.cvtColor(img_rgb, cv2.COLOR_RGB2HSV)

## HSV to RGB.
def hsv2rgb(img):
    rgb = cv2.cvtColor(img, cv2.COLOR_HSV2RGB)
    return rgb

## Merge channels.
def merge(channels):
    cs = 0
    h = 0
    w = 0
    for channel in channels:
        if len(channel.shape) == 2:
            cs += 1
        else:
            cs += channel.shape[2]
        h, w = channel.shape[0], channel.shape[1]
    img = np.zeros((h, w, cs))
    ci = 0
    for channel in channels:
        if len(channel.shape) == 2:
            img[:, :, ci] = channel[:, :]
            ci += 1
            continue
        for cci in range(channel.shape[2]):
            img[:, :, ci] = channel[:, :, cci]
            ci += 1
    return img

## Luminance value from Lab.
#  Lumiannce value will be in [0, 1]
def luminance(img):
    L = rgb2Lab(rgb(img))[:, :, 0]
    if L.dtype != np.uint8:
        return (1.0 / 100.0) * L
return L
2.2 datasets.py
# -*- coding: utf-8 -*-
# # @package color_histogram.datasets.datasets
#
#  color_histogram.datasets.datasets utility package.
#  @author      tody
#  @date        2016/06/08
import os
from color_histogram.io_util.image import loadRGB
_root_dir = os.path.dirname(__file__)

# # Data directory for the given data_name.
def dataDir(data_name):
    data_dir = os.path.join(_root_dir, data_name)
    return data_dir

# # Data file path list for the given data_name.
def dataFiles(data_name):
    data_dir = dataDir(data_name)
    data_files = []
    for data_name in os.listdir(data_dir):
        data_file = os.path.join(data_dir, data_name)
        if ".png" in data_name or ".jpg" in data_name:
            data_files.append(data_file)
        else:
            os.remove(data_file)
    return data_files

# # Data file path for the given data_name and data_id.
def dataFile(data_name, data_id):
    data_files = dataFiles(data_name)
    if data_id >= len(data_files):

        return None
    data_file = data_files[data_id]
    return data_file

def loadData(data_name, data_id):
    data_file = dataFile(data_name, data_id)
    if data_file is None:
        return None
return loadRGB(data_file)
2.3 io_util.image.py
# -*- coding: utf-8 -*-
## @package color_histograms.io_util.image
#
#  Image IO utility package.
#  @author      tody
#  @date        2015/07/18
import cv2
from color_histogram.cv.image import *

def loadGray(file_path):
    bgr = cv2.imread(file_path)
    gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)
    return gray

def loadRGB(file_path):
    bgr = cv2.imread(file_path)
    if bgr is None:
        return None
    return bgr2rgb(bgr)

def loadRGBA(file_path):
    bgra = cv2.imread(file_path, -1)
    if bgra is None:
        return None
    return bgra2rgba(bgra)

def loadAlpha(file_path):
    bgra = cv2.imread(file_path, -1)
    return alpha(bgra)

def saveRGBA(file_path, img):
    bgra = rgba2bgra(img)
    cv2.imwrite(file_path, bgra)

def saveRGB(file_path, img):
    bgr = rgb2bgr(img)
    cv2.imwrite(file_path, bgr)

def saveGray(file_path, img):
    rgbImg = rgb(img)
    cv2.imwrite(file_path, rgbImg)

def saveImage(file_path, img):
    img_8U = to8U(img)
    if len(img_8U.shape) == 2:
        saveGray(file_path, img_8U)
        return
    if img_8U.shape[2] == 3:
        saveRGB(file_path, img_8U)
        return
    if img_8U.shape[2] == 4:
        saveRGBA(file_path, img_8U)
        return
2.4 np.norm.py
# -*- coding: utf-8 -*-
## @package color_histogram.np.norm
#
#  Norm functions.
#  @author      tody
#  @date        2015/07/18
import numpy as np

## True if x is a vector.
def isVector(x):
    return x.size == x.shape[0]

## True if x is a matrix.
def isMatrix(x):
    return not isVector(x)

## Normalize vector.
def normalizeVector(x):
    norm = np.linalg.norm(x)
    y = x
    if norm > 0:
        y = np.ravel((1.0 / norm) * x)
    return y

## Normalize vectors (n x m matrix).
def normalizeVectors(x):
    norm = normVectors(x)
    nonZeroIDs = norm > 0
    x[nonZeroIDs] = (x[nonZeroIDs].T / norm[nonZeroIDs]).T
    return x

## Norm of vectors (n x m matrix).
def normVectors(x):
    return np.sqrt(l2NormVectors(x))

## L2 norm of vectors (n x m matrix).
#  n x 1 vector: call np.square.
#  n x m vectors: call np.einsum.
def l2NormVectors(x):
    if isVector(x):
        return np.square(x)
    else:
        return np.einsum('...i,...i', x, x)
2.5 plot.fig2np
# -*- coding: utf-8 -*-
# # @package color_histogram.plot.fig2np
#
#  color_histogram.plot.fig2np utility package.
#  @author      tody
#  @date        2016/06/08

import numpy as np

# #  Convert matplot figure to numpy.array
def figure2numpy(fig, call_draw=True):
    if call_draw:
        fig.canvas.draw()
    fig_data = np.fromstring(fig.canvas.tostring_rgb(), dtype=np.uint8, sep='')
    image = fig_data.reshape(fig.canvas.get_width_height()[::-1] + (3,))
    return image
2.6 plot.window.py
# -*- coding: utf-8 -*-
## @package color_histogram.plot.window
#
#  Matplot window functions.
#  @author      tody
#  @date        2015/07/29
from matplotlib import pyplot as plt

## Maximize the matplot window.
def showMaximize():
    mng = plt.get_current_fig_manager()
    mng.window.state('zoomed')
    plt.show()
2.7 core.hist_2d.py
# -*- coding: utf-8 -*-
## @package color_histogram.core.hist_2d
#
#  Implementation of 2D color histograms.
#  @author      tody
#  @date        2015/08/28
import numpy as np
from color_histogram.core.color_pixels import ColorPixels
from color_histogram.core.hist_common import colorCoordinates, colorDensities, rgbColors, clipLowDensity, range2ticks,\
    densitySizes, range2lims

## Implementation of 2D color histograms.
class Hist2D:
    ## Constructor
    #  @param image          input image.
    #  @param num_bins       target number of histogram bins.
    #  @param alpha          low density clip.
    #  @param color_space    target color space. 'rgb' or 'Lab' or 'hsv'.
    #  @param channels       target color channels. [0, 1] with 'hsv' means (h, s) channels.
    def __init__(self, image, num_bins=16, alpha=0.1, color_space='hsv', channels=[0, 1]):
        self._computeTargetPixels(image, color_space, channels)
        self._num_bins = num_bins
        self._alpha = alpha
        self._color_space = color_space
        self._channels = channels
        self._computeColorRange()
        self._computeHistogram()
        self._plotter = Hist2DPlot(self)
    ## Plot histogram with the given density size range.
    def plot(self, ax, density_size_range=[10, 100]):
        self._plotter.plot(ax, density_size_range)
    def colorSpace(self):
        return self._color_space
    def channels(self):
        return self._channels
    def colorIDs(self):
        color_ids = np.where(self._histPositive())
        return color_ids
    def colorCoordinates(self):
        color_ids = self.colorIDs()
        num_bins = self._num_bins
        color_range = self._color_range
        return colorCoordinates(color_ids, num_bins, color_range)
    def colorDensities(self):
        return colorDensities(self._hist_bins)
    def rgbColors(self):
        return rgbColors(self._hist_bins, self._color_bins)
    def colorRange(self):
        return self._color_range
    def _computeTargetPixels(self, image, color_space, channels):
        color_pixels = ColorPixels(image)
        self._pixels = color_pixels.pixels(color_space)[:, channels]
        self._rgb_pixels = color_pixels.rgb()
    def _computeColorRange(self):
        pixels = self._pixels
        cs = pixels.shape[1]
        c_min = np.zeros(cs)
        c_max = np.zeros(cs)
        for ci in xrange(cs):
            c_min[ci] = np.min(pixels[:, ci])
            c_max[ci] = np.max(pixels[:, ci])
        self._color_range = [c_min, c_max]
    def _computeHistogram(self):
        pixels = self._pixels
        num_bins = self._num_bins
        c_min, c_max = self._color_range
        hist_bins = np.zeros((num_bins, num_bins), dtype=np.float32)
        color_bins = np.zeros((num_bins, num_bins, 3), dtype=np.float32)
        color_ids = (num_bins - 1) * (pixels - c_min) / (c_max - c_min)
        color_ids = np.int32(color_ids)
        for pi, color_id in enumerate(color_ids):
            hist_bins[color_id[0], color_id[1]] += 1
            color_bins[color_id[0], color_id[1]] += self._rgb_pixels[pi]
        self._hist_bins = hist_bins
        hist_positive = self._hist_bins > 0.0
        for ci in xrange(3):
            color_bins[hist_positive, ci] /= self._hist_bins[hist_positive]
        self._color_bins = color_bins
        self._clipLowDensity()
    def _clipLowDensity(self):
        clipLowDensity(self._hist_bins, self._color_bins, self._alpha)
    def _histPositive(self):
        return self._hist_bins > 0.0

## 2D color histogram plotter.
class Hist2DPlot:
    ## Constructor.
    #  @param hist2D histogram for plotting.
    def __init__(self, hist2D):
        self._hist2D = hist2D
    ## Plot histogram with the given density size range.
    def plot(self, ax, density_size_range=[10, 100]):
        color_samples = self._hist2D.colorCoordinates()
        density_sizes = self._densitySizes(density_size_range)
        colors = self._hist2D.rgbColors()
        ax.scatter(color_samples[:, 0], color_samples[:, 1], color=colors, s=density_sizes)
        self._axisSetting(ax)
    def _densitySizes(self, density_size_range):
        color_densities = self._hist2D.colorDensities()
        return densitySizes(color_densities, density_size_range)
    def _axisSetting(self, ax):
        color_space = self._hist2D.colorSpace()
        channels = self._hist2D.channels()
        ax.set_xlabel(color_space[channels[0]])
        ax.set_ylabel(color_space[channels[1]], rotation='horizontal')
        color_range = self._hist2D.colorRange()
        tick_range = np.array(color_range).T
        xticks, yticks = range2ticks(tick_range)
        ax.set_xticks(xticks)
        ax.set_yticks(yticks)
        xlim, ylim = range2lims(tick_range)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
2.8 core.hist_3d.py
# -*- coding: utf-8 -*-
## @package color_histogram.core.hist_3d
#
#  Implementation of 3D color histograms.
#  @author      tody
#  @date        2015/08/28
import numpy as np
from color_histogram.core.color_pixels import ColorPixels
from color_histogram.core.hist_common import colorCoordinates, colorDensities, rgbColors, clipLowDensity, range2ticks,\
    densitySizes, range2lims

## Implementation of 3D color histograms.
class Hist3D:
    ## Constructor
    #  @param image          input image.
    #  @param num_bins       target number of histogram bins.
    #  @param alpha          low density clip.
    #  @param color_space    target color space. 'rgb' or 'Lab' or 'hsv'.
    def __init__(self, image,
                 num_bins=16, alpha=0.1, color_space='rgb'):
        self._computeTargetPixels(image, color_space)
        self._num_bins = num_bins
        self._alpha = alpha
        self._color_space = color_space
        self._computeColorRange()
        self._computeHistogram()
        self._plotter = Hist3DPlot(self)
    ## Plot histogram with the given density size range.
    def plot(self, ax, density_size_range=[10, 100]):
        self._plotter.plot(ax, density_size_range)
    def colorSpace(self):
        return self._color_space
    def colorIDs(self):
        color_ids = np.where(self._histPositive())
        return color_ids
    def colorCoordinates(self):
        color_ids = self.colorIDs()
        num_bins = self._num_bins
        color_range = self._color_range
        return colorCoordinates(color_ids, num_bins, color_range)
    def colorDensities(self):
        return colorDensities(self._hist_bins)
    def rgbColors(self):
        return rgbColors(self._hist_bins, self._color_bins)
    def colorRange(self):
        return self._color_range
    def _computeTargetPixels(self, image, color_space):
        color_pixels = ColorPixels(image)
        self._pixels = color_pixels.pixels(color_space)
        self._rgb_pixels = color_pixels.rgb()
    def _computeColorRange(self):
        pixels = self._pixels
        cs = pixels.shape[1]
        c_min = np.zeros(cs)
        c_max = np.zeros(cs)
        for ci in xrange(cs):
            c_min[ci] = np.min(pixels[:, ci])
            c_max[ci] = np.max(pixels[:, ci])
        self._color_range = [c_min, c_max]
    def _computeHistogram(self):
        pixels = self._pixels
        num_bins = self._num_bins
        c_min, c_max = self._color_range
        hist_bins = np.zeros((num_bins, num_bins, num_bins), dtype=np.float32)
        color_bins = np.zeros((num_bins, num_bins, num_bins, 3), dtype=np.float32)
        color_ids = (num_bins - 1) * (pixels - c_min) / (c_max - c_min)
        color_ids = np.int32(color_ids)
        for pi, color_id in enumerate(color_ids):
            hist_bins[color_id[0], color_id[1], color_id[2]] += 1
            color_bins[color_id[0], color_id[1], color_id[2]] += self._rgb_pixels[pi]
        self._hist_bins = hist_bins
        hist_positive = self._hist_bins > 0.0
        for ci in xrange(3):
            color_bins[hist_positive, ci] /= self._hist_bins[hist_positive]
        self._color_bins = color_bins
        self._clipLowDensity()
    def _clipLowDensity(self):
        clipLowDensity(self._hist_bins, self._color_bins, self._alpha)
    def _histPositive(self):
        return self._hist_bins > 0.0

## 3D color histogram plotter.
class Hist3DPlot:
    ## Constructor.
    #  @param hist3D histogram for plotting.
    def __init__(self, hist3D):
        self._hist3D = hist3D
    ## Plot histogram with the given density size range.
    def plot(self, ax, density_size_range=[10, 100]):
        color_samples = self._hist3D.colorCoordinates()
        density_sizes = self._densitySizes(density_size_range)
        colors = self._hist3D.rgbColors()
        ax.scatter(color_samples[:, 0], color_samples[:, 1], color_samples[:, 2], color=colors, s=density_sizes)
        self._axisSetting(ax)
    def _densitySizes(self, density_size_range):
        color_densities = self._hist3D.colorDensities()
        return densitySizes(color_densities, density_size_range)
    def _axisSetting(self, ax):
        color_space = self._hist3D.colorSpace()
        ax.set_xlabel(color_space[0])
        ax.set_ylabel(color_space[1])
        ax.set_zlabel(color_space[2])
        color_range = self._hist3D.colorRange()
        tick_range = np.array(color_range).T
        xticks, yticks, zticks = range2ticks(tick_range)
        ax.set_xticks(xticks)
        ax.set_yticks(yticks)
        ax.set_zticks(zticks)
        xlim, ylim, zlim = range2lims(tick_range)
        ax.set_xlim(xlim)
        ax.set_ylim(ylim)
        ax.set_zlim(zlim)
2.9 google_image.py
# -*- coding: utf-8 -*-
# # @package color_histogram.datasets.google_image
#
#  Image datasets via Google Image API.
#  createDatasets function will create datasets
#  with the following direcotry structure.
#
#  * datasets
#    - apple
#      - apple_1.jpg
#    - banana
#      - banana_1.jpg
#
#  @author      tody
#  @date        2015/08/15

import json
import os
import urllib2
import httplib2
import cv2
import matplotlib.pyplot as plt
from color_histogram.io_util.image import loadRGB, saveRGB
from color_histogram.datasets.datasets import dataDir, dataFiles

# # Simple image loaders via Google image API.
class GoogleImageLoader:
    # # Constructor
    #  @param keyword     keyword for image search.
    #  @param num_images  target number of images for the search.
    #  @param update      Update existing images if the value is True.
    def __init__(self, keyword="banana", num_images=10, update=False):
        self._keyword = keyword
        self._num_images = num_images
        self._data_dir = dataDir(keyword)
        self._update = update
        self.searchImageURLs()
        self.downloadImages()
        self.postResize()
    def searchImageURLs(self):
        keyword = self._keyword
        num_images = self._num_images
        image_urls = []
        google_api = "http://ajax.googleapis.com/ajax/services/search/images?q={0}&v=1.0&rsz=large&start={1}&imgc=color"
        for i in range((num_images / 8) + 1):
            res = urllib2.urlopen(google_api.format(keyword, i * 8))
            page_data = json.load(res)
            page_urls = [result["url"] for result in page_data["responseData"]["results"]]
            image_urls.extend(page_urls)
        if len(image_urls) >= num_images:
            image_urls = image_urls[:num_images]
        self._image_urls = image_urls
        return image_urls
    def downloadImages(self):
        print "  Download"
        data_name = self._keyword
        image_urls = self._image_urls
        data_dir = self._data_dir
        if os.path.exists(data_dir) == False:
            os.makedirs(data_dir)
        http = httplib2.Http(".cache")
        for i in range(len(set(image_urls))):
            try:
                url_name, ext = os.path.splitext(image_urls[i])
                data_filename = "%s_%s%s" % (data_name, i, ext)
                data_filepath = os.path.join(data_dir, data_filename)
                if not self._update:
                    if os.path.exists(data_filepath):
                        print "  - Skip: %s" % data_filename
                        continue
                response, content = http.request(image_urls[i])
                with open(data_filepath, 'wb') as data_file:
                    data_file.write(content)
                    print "  - Done: %s" % data_filename
            except:
                continue
    def postResize(self):
        print "  Post resize"
        data_name = self._keyword
        data_files = dataFiles(data_name)
        for data_file in data_files:
            data_filename = os.path.basename(data_file)
            C_8U = loadRGB(data_file)
            if C_8U is None:
                os.remove(data_file)
                print "  - Delete: %s" % data_filename
                continue
            h, w = C_8U.shape[0:2]
            opt_scale = 800.0 / float(h)
            opt_scale = max(opt_scale, 800.0 / float(w))
            opt_scale = min(opt_scale, 1.0)
            h_opt = int(opt_scale * h)
            w_opt = int(opt_scale * w)
            C_8U_small = cv2.resize(C_8U, (w_opt, h_opt))
            saveRGB(data_file, C_8U_small)
            print "  - Resized: %s" % data_filename

# # Create dataset for the given data_name.
def createDataset(data_name="banana", num_images=10, update=False):
    GoogleImageLoader(data_name, num_images, update)

# # Create datasets for the given data_names.
def createDatasets(data_names=["apple", "banana", "sky", "tulip", "flower"],
                   num_images=10,
                   update=False):
    for data_name in data_names:
        print "Create datasets: %s" % data_name
        createDataset(data_name, num_images, update)

if __name__ == '__main__':
    createDatasets()
2.10 results.hist_1d.py
# -*- coding: utf-8 -*-
# # @package color_histogram.results.hist_1d
#
#  Compute 1D color histogram result.
#  @author      tody
#  @date        2015/08/28
import os
import numpy as np
import matplotlib.pyplot as plt
from color_histogram.io_util.image import loadRGB
from color_histogram.cv.image import rgb, to32F
from color_histogram.datasets.datasets import dataFile
from color_histogram.results.results import resultFile, batchResults
from color_histogram.plot.window import showMaximize
from color_histogram.util.timer import timing_func
from color_histogram.core.hist_1d import Hist1D

# # Plot 1D color histograms for the target image, color space, channels.
@timing_func
def plotHistogram1D(image, num_bins, color_space, channel, ax):
    font_size = 15
    plt.title("%s (%s): %s bins" % (color_space,
                                        color_space[channel],
                                        num_bins), fontsize=font_size)
    hist1D = Hist1D(image, num_bins=num_bins, color_space=color_space, channel=channel)
    hist1D.plot(ax)

# # Create histogram 1D result function.
def histogram1DResultFunc(num_bins=32):
    def func(image_file):
        histogram1DResult(image_file, num_bins)
    return func

# # Compute histogram 1D result for the image file.
def histogram1DResult(image_file, num_bins=32, image=None, tile=None):
    image_name = os.path.basename(image_file)
    if image is None:
        image_name = os.path.basename(image_file)
        image_name = os.path.splitext(image_name)[0]
        image = loadRGB(image_file)
    if tile is None:
        tile = image
    fig_w = 10
    fig_h = 6
    fig = plt.figure(figsize=(fig_w, fig_h))
    fig.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.95, wspace=0.3, hspace=0.2)
    font_size = 15
    fig.suptitle("Hisotogram 1D", fontsize=font_size)
    h, w = image.shape[:2]
    fig.add_subplot(231)
    plt.title("Original Image: %s x %s" % (w, h), fontsize=font_size)
    plt.imshow(tile)
    plt.axis('off')
    color_targets = [["Lab", 0], ["hsv", 0], ["hsv", 2]]
    plot_id = 234
    for color_target in color_targets:
        ax = fig.add_subplot(plot_id)
        color_space, channel = color_target
        plotHistogram1D(image, num_bins, color_space, channel, ax)
        plot_id += 1
    result_name = image_name + "_hist1D"
    result_file = resultFile(result_name)
    plt.savefig(result_file, transparent=True)


# # Compute histogram 1D results for the given data names, ids.
def histogram1DResults(data_names, data_ids, num_bins=16):
    batchResults(data_names, data_ids, histogram1DResultFunc(num_bins), "Histogram 1D")

if __name__ == '__main__':
    data_names = ["flower"]
    data_ids = [0, 1, 2]
    histogram1DResults(data_names, data_ids)
2.11 results.hist_2d.py
# -*- coding: utf-8 -*-
# # @package color_histogram.results.hist_2d
#
#  Compute 2D color histogram result.
#  @author      tody
#  @date        2015/08/28
import os
import numpy as np
import matplotlib.pyplot as plt
from color_histogram.io_util.image import loadRGB
from color_histogram.cv.image import rgb, to32F
from color_histogram.datasets.datasets import dataFile
from color_histogram.results.results import resultFile, batchResults
from color_histogram.plot.window import showMaximize
from color_histogram.core.hist_2d import Hist2D
from color_histogram.util.timer import timing_func

# # Plot 2D color histograms for the target image, color space, channels.
@timing_func
def plotHistogram2D(image, num_bins, color_space, channels, ax):
    font_size = 15
    plt.title("%s (%s, %s): %s bins" % (color_space,
                                        color_space[channels[0]],
                                        color_space[channels[1]],
                                        num_bins), fontsize=font_size)
    hist2D = Hist2D(image, num_bins=num_bins, color_space=color_space, channels=channels)
    hist2D.plot(ax)

# # Create histogram 2D result function.
def histogram2DResultFunc(num_bins=32):
    def func(image_file):
        histogram2DResult(image_file, num_bins)
    return func

# # Compute histogram 2D result for the image file.
def histogram2DResult(image_file, num_bins=32, image=None, tile=None):
    image_name = os.path.basename(image_file)
    if image is None:
        image_name = os.path.basename(image_file)
        image_name = os.path.splitext(image_name)[0]
        image = loadRGB(image_file)
    if tile is None:
        tile = image
    fig_w = 10
    fig_h = 6
    fig = plt.figure(figsize=(fig_w, fig_h))
    fig.subplots_adjust(left=0.1, bottom=0.1, right=0.9, top=0.95, wspace=0.3, hspace=0.2)
    font_size = 15
    fig.suptitle("Hisotogram 2D", fontsize=font_size)
    h, w = image.shape[:2]
    fig.add_subplot(231)
    plt.title("Original Image: %s x %s" % (w, h), fontsize=font_size)
    plt.imshow(tile)
    plt.axis('off')
    color_space = "hsv"
    channels_list = [[0, 1], [0, 2], [1, 2]]
    plot_id = 234
    for channels in channels_list:
        ax = fig.add_subplot(plot_id)
        plotHistogram2D(image, num_bins, color_space, channels, ax)
        plot_id += 1
    result_name = image_name + "_hist2D"
    result_file = resultFile(result_name)
    plt.savefig(result_file, transparent=True)

# # Compute histogram 2D results for the given data names, ids.
def histogram2DResults(data_names, data_ids, num_bins=32):
    batchResults(data_names, data_ids, histogram2DResultFunc(num_bins), "Histogram 2D")
if __name__ == '__main__':
    data_names = ["flower"]
    data_ids = [0, 1, 2]
    histogram2DResults(data_names, data_ids)
2.12 results.hist_3d.py
# -*- coding: utf-8 -*-
# # @package color_histogram.results.hist_3d
#
#  cCompute 3D color histogram result.
#  @author      tody
#  @date        2015/08/28
import os
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from color_histogram.io_util.image import loadRGB
from color_histogram.cv.image import rgb, to32F, rgb2Lab, rgb2hsv
from color_histogram.core.hist_3d import Hist3D
from color_histogram.datasets.datasets import dataFile
from color_histogram.results.results import resultFile, batchResults
from color_histogram.plot.window import showMaximize
from color_histogram.util.timer import timing_func

# # Plot 3D color histograms for the target image, color space, channels.
@timing_func
def plotHistogram3D(image, num_bins, color_space, ax):
    font_size = 15
    plt.title("%s: %s bins" % (color_space, num_bins), fontsize=font_size)
    hist3D = Hist3D(image, num_bins=num_bins, color_space=color_space)
    hist3D.plot(ax)

# # Create histogram 3D result function.
def histogram3DResultFunc(num_bins=32):
    def func(image_file):
        histogram3DResult(image_file, num_bins)
    return func

# # Compute histogram 3D result for the image file.
def histogram3DResult(image_file, num_bins=32, image=None, tile=None):
    image_name = os.path.basename(image_file)
    if image is None:
        image_name = os.path.basename(image_file)
        image_name = os.path.splitext(image_name)[0]
        image = loadRGB(image_file)
    if tile is None:
        tile = image
    fig_w = 10
    fig_h = 6
    fig = plt.figure(figsize=(fig_w, fig_h))
    fig.subplots_adjust(left=0.05, bottom=0.05, right=0.95, top=0.95, wspace=0.02, hspace=0.2)
    font_size = 15
    fig.suptitle("Hisotogram 3D", fontsize=font_size)
    h, w = image.shape[:2]
    fig.add_subplot(231)
    plt.title("Original Image: %s x %s" % (w, h), fontsize=font_size)
    plt.imshow(tile)
    plt.axis('off')
    color_spaces = ["rgb", "Lab", "hsv"]
    plot_id = 234
    for color_space in color_spaces:
        ax = fig.add_subplot(plot_id, projection='3d')
        plotHistogram3D(image, num_bins, color_space, ax)
        plot_id += 1
    result_name = image_name + "_hist3D"
    result_file = resultFile(result_name)
    plt.savefig(result_file, transparent=True)

# # Compute histogram 3D results for the data names, ids.
def histogram3DResults(data_names, data_ids, num_bins=32):
    batchResults(data_names, data_ids, histogram3DResultFunc(num_bins), "Histogram 3D")
if __name__ == '__main__':
    data_names = ["flower"]
    data_ids = [0, 1, 2]
    histogram3DResults(data_names, data_ids)
2.13 results.multi_images.py
# -*- coding: utf-8 -*-
# # @package color_histogram.results.multi_images
#
#  color_histogram.results.multi_images utility package.
#  @author      tody
#  @date        2016/06/08
import numpy as np
import matplotlib.pyplot as plt
from color_histogram.core.color_pixels import ColorPixels
from color_histogram.datasets.datasets import dataFile
from color_histogram.io_util.image import loadRGB
from color_histogram.results.results import batchResults, batchDataGroup
from color_histogram.plot.fig2np import figure2numpy
from color_histogram.results.hist_1d import histogram1DResult
from color_histogram.results.hist_2d import histogram2DResult
from color_histogram.results.hist_3d import histogram3DResult

# # Create multi-image pixels.
def createMultiImagePixels(data_name, data_ids):
    rgb_pixels = []
    num_cols = 3
    num_rows = (len(data_ids) + 2) / num_cols
    fig = plt.figure(figsize=(10, 7))
    fig.subplots_adjust(left=0.05, bottom=0.05, right=0.95, top=0.95, wspace=0.1, hspace=0.1)
    font_size = 15
    plot_id = 1
    for data_id in data_ids:
        image_file = dataFile(data_name, data_id)
        image = loadRGB(image_file)
        rgb_pixels.extend(ColorPixels(image).rgb())
        fig.add_subplot(num_rows, num_cols, plot_id)
        plt.imshow(image)
        plt.axis('off')
        plot_id += 1
    rgb_pixels = np.array(rgb_pixels)
    multi_image = np.array(rgb_pixels).reshape(1, -1, 3)
    multi_tile = figure2numpy(fig)
    return multi_image, multi_tile

def hist1DMultiResultFunc(num_bins=32):
    def func(data_name, data_ids):
        multi_image, multi_tile = createMultiImagePixels(data_name, data_ids)
        histogram1DResult(data_name + "_multi", num_bins, multi_image, multi_tile)
    return func

# # Compute multi-image results for the given data names, ids.
def hist1DMultiResults(data_names, data_ids, num_bins=32):
    batchDataGroup(data_names, data_ids, hist1DMultiResultFunc(num_bins), "Histogram 1D(multi images)")

def hist2DMultiResultFunc(num_bins=32):
    def func(data_name, data_ids):
        multi_image, multi_tile = createMultiImagePixels(data_name, data_ids)
        histogram2DResult(data_name + "_multi", num_bins, multi_image, multi_tile)
    return func

# # Compute multi-image results for the given data names, ids.
def hist2DMultiResults(data_names, data_ids, num_bins=32):
    batchDataGroup(data_names, data_ids, hist2DMultiResultFunc(num_bins), "Histogram 2D(multi images)")

def hist3DMultiResultFunc(num_bins=32):
    def func(data_name, data_ids):
        multi_image, multi_tile = createMultiImagePixels(data_name, data_ids)
        histogram3DResult(data_name + "_multi", num_bins, multi_image, multi_tile)
    return func

# # Compute multi-image results for the given data names, ids.
def hist3DMultiResults(data_names, data_ids, num_bins=32):
    batchDataGroup(data_names, data_ids, hist3DMultiResultFunc(num_bins), "Histogram 3D(multi images)")
2.14 results.results.py
# -*- coding: utf-8 -*-
# # @package color_histogram.results.results
#
#  Results utility package.
#  @author      tody
#  @date        2015/08/20
import os
from color_histogram.datasets.datasets import dataFile
_root_dir = os.path.dirname(__file__)

# # Result directory.
def resultDir():
    return _root_dir

# # Result file.
def resultFile(image_name, image_ext=".png"):
    result_file = os.path.join(resultDir(), image_name + image_ext)
    return result_file

def batchResults(data_names, data_ids, batch_func, batch_name):
    for data_name in data_names:
        print "%s: %s" % (batch_name, data_name)
        for data_id in data_ids:
            print "Data ID: %s" % data_id
            image_file = dataFile(data_name, data_id)
            batch_func(image_file)

# # Batch command for the target data group.
#
#  @param batch_func batch_func(data_name, data_ids) for a data group.
#  @param batch_name batch command name.
def batchDataGroup(data_names, data_ids, batch_func, batch_name):
    for data_name in data_names:
        print "%s: %s" % (batch_name, data_name)
        batch_func(data_name, data_ids)
if __name__ == '__main__':
    print resultDir()
    print resultFile("testImage")
2.15 QGraphicsScene.py
# encoding: utf-8
# module PyQt4.QtGui
# from c:\python27\lib\site-packages\PyQt4\QtGui.pyd
# by generator 1.144
# no doc
# imports
import PyQt4.QtCore as __PyQt4_QtCore

class QGraphicsScene(__PyQt4_QtCore.QObject):
    """
    QGraphicsScene(QObject parent=None)
    QGraphicsScene(QRectF, QObject parent=None)
    QGraphicsScene(float, float, float, float, QObject parent=None)
    """
    def activePanel(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.activePanel() -> QGraphicsItem """
        return QGraphicsItem
    def activeWindow(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.activeWindow() -> QGraphicsWidget """
        return QGraphicsWidget
    def addEllipse(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.addEllipse(QRectF, QPen pen=QPen(), QBrush brush=QBrush()) -> QGraphicsEllipseItem
        QGraphicsScene.addEllipse(float, float, float, float, QPen pen=QPen(), QBrush brush=QBrush()) -> QGraphicsEllipseItem
        """
        pass
    def addItem(self, QGraphicsItem): # real signature unknown; restored from __doc__
        """ QGraphicsScene.addItem(QGraphicsItem) """
        pass
    def addLine(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.addLine(QLineF, QPen pen=QPen()) -> QGraphicsLineItem
        QGraphicsScene.addLine(float, float, float, float, QPen pen=QPen()) -> QGraphicsLineItem
        """
        pass
    def addPath(self, QPainterPath, QPen_pen=None, *args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__
        """ QGraphicsScene.addPath(QPainterPath, QPen pen=QPen(), QBrush brush=QBrush()) -> QGraphicsPathItem """
        pass
    def addPixmap(self, QPixmap): # real signature unknown; restored from __doc__
        """ QGraphicsScene.addPixmap(QPixmap) -> QGraphicsPixmapItem """
        return QGraphicsPixmapItem
    def addPolygon(self, QPolygonF, QPen_pen=None, *args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__
        """ QGraphicsScene.addPolygon(QPolygonF, QPen pen=QPen(), QBrush brush=QBrush()) -> QGraphicsPolygonItem """
        pass
    def addRect(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.addRect(QRectF, QPen pen=QPen(), QBrush brush=QBrush()) -> QGraphicsRectItem
        QGraphicsScene.addRect(float, float, float, float, QPen pen=QPen(), QBrush brush=QBrush()) -> QGraphicsRectItem
        """
        pass
    def addSimpleText(self, QString, QFont_font=None, *args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__
        """ QGraphicsScene.addSimpleText(QString, QFont font=QFont()) -> QGraphicsSimpleTextItem """
        pass
    def addText(self, QString, QFont_font=None, *args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__
        """ QGraphicsScene.addText(QString, QFont font=QFont()) -> QGraphicsTextItem """
        pass
    def addWidget(self, QWidget, Qt_WindowFlags_flags=0): # real signature unknown; restored from __doc__
        """ QGraphicsScene.addWidget(QWidget, Qt.WindowFlags flags=0) -> QGraphicsProxyWidget """
        return QGraphicsProxyWidget
    def advance(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.advance() """
        pass
    def backgroundBrush(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.backgroundBrush() -> QBrush """
        return QBrush
    def bspTreeDepth(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.bspTreeDepth() -> int """
        return 0
    def changed(self, *args, **kwargs): # real signature unknown
        """ QGraphicsScene.changed[list-of-QRectF] [signal] """
        pass
    def childEvent(self, *args, **kwargs): # real signature unknown
        pass
    def clear(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.clear() """
        pass
    def clearFocus(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.clearFocus() """
        pass
    def clearSelection(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.clearSelection() """
        pass
    def collidingItems(self, QGraphicsItem, Qt_ItemSelectionMode_mode=None): # real signature unknown; restored from __doc__
        """ QGraphicsScene.collidingItems(QGraphicsItem, Qt.ItemSelectionMode mode=Qt.IntersectsItemShape) -> list-of-QGraphicsItem """
        pass
    def connectNotify(self, *args, **kwargs): # real signature unknown
        pass
    def contextMenuEvent(self, QGraphicsSceneContextMenuEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.contextMenuEvent(QGraphicsSceneContextMenuEvent) """
        pass
    def createItemGroup(self, list_of_QGraphicsItem): # real signature unknown; restored from __doc__
        """ QGraphicsScene.createItemGroup(list-of-QGraphicsItem) -> QGraphicsItemGroup """
        return QGraphicsItemGroup
    def customEvent(self, *args, **kwargs): # real signature unknown
        pass
    def destroyItemGroup(self, QGraphicsItemGroup): # real signature unknown; restored from __doc__
        """ QGraphicsScene.destroyItemGroup(QGraphicsItemGroup) """
        pass
    def disconnectNotify(self, *args, **kwargs): # real signature unknown
        pass
    def dragEnterEvent(self, QGraphicsSceneDragDropEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.dragEnterEvent(QGraphicsSceneDragDropEvent) """
        pass
    def dragLeaveEvent(self, QGraphicsSceneDragDropEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.dragLeaveEvent(QGraphicsSceneDragDropEvent) """
        pass
    def dragMoveEvent(self, QGraphicsSceneDragDropEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.dragMoveEvent(QGraphicsSceneDragDropEvent) """
        pass
    def drawBackground(self, QPainter, QRectF): # real signature unknown; restored from __doc__
        """ QGraphicsScene.drawBackground(QPainter, QRectF) """
        pass
    def drawForeground(self, QPainter, QRectF): # real signature unknown; restored from __doc__
        """ QGraphicsScene.drawForeground(QPainter, QRectF) """
        pass
    def drawItems(self, QPainter, list_of_QGraphicsItem, list_of_QStyleOptionGraphicsItem, QWidget_widget=None): # real signature unknown; restored from __doc__
        """ QGraphicsScene.drawItems(QPainter, list-of-QGraphicsItem, list-of-QStyleOptionGraphicsItem, QWidget widget=None) """
        pass
    def dropEvent(self, QGraphicsSceneDragDropEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.dropEvent(QGraphicsSceneDragDropEvent) """
        pass
    def event(self, QEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.event(QEvent) -> bool """
        return False
    def eventFilter(self, QObject, QEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.eventFilter(QObject, QEvent) -> bool """
        return False
    def focusInEvent(self, QFocusEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.focusInEvent(QFocusEvent) """
        pass
    def focusItem(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.focusItem() -> QGraphicsItem """
        return QGraphicsItem
    def focusNextPrevChild(self, bool): # real signature unknown; restored from __doc__
        """ QGraphicsScene.focusNextPrevChild(bool) -> bool """
        return False
    def focusOutEvent(self, QFocusEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.focusOutEvent(QFocusEvent) """
        pass
    def font(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.font() -> QFont """
        return QFont
    def foregroundBrush(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.foregroundBrush() -> QBrush """
        return QBrush
    def hasFocus(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.hasFocus() -> bool """
        return False
    def height(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.height() -> float """
        return 0.0
    def helpEvent(self, QGraphicsSceneHelpEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.helpEvent(QGraphicsSceneHelpEvent) """
        pass
    def inputMethodEvent(self, QInputMethodEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.inputMethodEvent(QInputMethodEvent) """
        pass
    def inputMethodQuery(self, Qt_InputMethodQuery): # real signature unknown; restored from __doc__
        """ QGraphicsScene.inputMethodQuery(Qt.InputMethodQuery) -> QVariant """
        pass
    def invalidate(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.invalidate(QRectF rect=QRectF(), QGraphicsScene.SceneLayers layers=QGraphicsScene.AllLayers)
        QGraphicsScene.invalidate(float, float, float, float, QGraphicsScene.SceneLayers layers=QGraphicsScene.AllLayers)
        """
        pass
    def isActive(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.isActive() -> bool """
        return False
    def isSortCacheEnabled(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.isSortCacheEnabled() -> bool """
        return False
    def itemAt(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.itemAt(QPointF) -> QGraphicsItem
        QGraphicsScene.itemAt(float, float) -> QGraphicsItem
        QGraphicsScene.itemAt(QPointF, QTransform) -> QGraphicsItem
        QGraphicsScene.itemAt(float, float, QTransform) -> QGraphicsItem
        """
        return QGraphicsItem
    def itemIndexMethod(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.itemIndexMethod() -> QGraphicsScene.ItemIndexMethod """
        pass
    def items(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.items() -> list-of-QGraphicsItem
        QGraphicsScene.items(Qt.SortOrder) -> list-of-QGraphicsItem
        QGraphicsScene.items(QPointF) -> list-of-QGraphicsItem
        QGraphicsScene.items(QPointF, Qt.ItemSelectionMode, Qt.SortOrder, QTransform deviceTransform=QTransform()) -> list-of-QGraphicsItem
        QGraphicsScene.items(QRectF, Qt.ItemSelectionMode mode=Qt.IntersectsItemShape) -> list-of-QGraphicsItem
        QGraphicsScene.items(QRectF, Qt.ItemSelectionMode, Qt.SortOrder, QTransform deviceTransform=QTransform()) -> list-of-QGraphicsItem
        QGraphicsScene.items(QPolygonF, Qt.ItemSelectionMode mode=Qt.IntersectsItemShape) -> list-of-QGraphicsItem
        QGraphicsScene.items(QPolygonF, Qt.ItemSelectionMode, Qt.SortOrder, QTransform deviceTransform=QTransform()) -> list-of-QGraphicsItem
        QGraphicsScene.items(QPainterPath, Qt.ItemSelectionMode mode=Qt.IntersectsItemShape) -> list-of-QGraphicsItem
        QGraphicsScene.items(QPainterPath, Qt.ItemSelectionMode, Qt.SortOrder, QTransform deviceTransform=QTransform()) -> list-of-QGraphicsItem
        QGraphicsScene.items(float, float, float, float, Qt.ItemSelectionMode mode=Qt.IntersectsItemShape) -> list-of-QGraphicsItem
        QGraphicsScene.items(float, float, float, float, Qt.ItemSelectionMode, Qt.SortOrder, QTransform deviceTransform=QTransform()) -> list-of-QGraphicsItem
        """
        pass
    def itemsBoundingRect(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.itemsBoundingRect() -> QRectF """
        pass
    def keyPressEvent(self, QKeyEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.keyPressEvent(QKeyEvent) """
        pass
    def keyReleaseEvent(self, QKeyEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.keyReleaseEvent(QKeyEvent) """
        pass
    def mouseDoubleClickEvent(self, QGraphicsSceneMouseEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.mouseDoubleClickEvent(QGraphicsSceneMouseEvent) """
        pass
    def mouseGrabberItem(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.mouseGrabberItem() -> QGraphicsItem """
        return QGraphicsItem
    def mouseMoveEvent(self, QGraphicsSceneMouseEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.mouseMoveEvent(QGraphicsSceneMouseEvent) """
        pass
    def mousePressEvent(self, QGraphicsSceneMouseEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.mousePressEvent(QGraphicsSceneMouseEvent) """
        pass
    def mouseReleaseEvent(self, QGraphicsSceneMouseEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.mouseReleaseEvent(QGraphicsSceneMouseEvent) """
        pass
    def palette(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.palette() -> QPalette """
        return QPalette
    def receivers(self, *args, **kwargs): # real signature unknown
        pass
    def removeItem(self, QGraphicsItem): # real signature unknown; restored from __doc__
        """ QGraphicsScene.removeItem(QGraphicsItem) """
        pass
    def render(self, QPainter, QRectF_target=None, *args, **kwargs): # real signature unknown; NOTE: unreliably restored from __doc__
        """ QGraphicsScene.render(QPainter, QRectF target=QRectF(), QRectF source=QRectF(), Qt.AspectRatioMode mode=Qt.KeepAspectRatio) """
        pass
    def sceneRect(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.sceneRect() -> QRectF """
        pass
    def sceneRectChanged(self, *args, **kwargs): # real signature unknown
        """ QGraphicsScene.sceneRectChanged[QRectF] [signal] """
        pass
    def selectedItems(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.selectedItems() -> list-of-QGraphicsItem """
        pass
    def selectionArea(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.selectionArea() -> QPainterPath """
        return QPainterPath
    def selectionChanged(self, *args, **kwargs): # real signature unknown
        """ QGraphicsScene.selectionChanged [signal] """
        pass
    def sender(self, *args, **kwargs): # real signature unknown
        pass
    def senderSignalIndex(self, *args, **kwargs): # real signature unknown
        pass
    def sendEvent(self, QGraphicsItem, QEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.sendEvent(QGraphicsItem, QEvent) -> bool """
        return False
    def setActivePanel(self, QGraphicsItem): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setActivePanel(QGraphicsItem) """
        pass
    def setActiveWindow(self, QGraphicsWidget): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setActiveWindow(QGraphicsWidget) """
        pass
    def setBackgroundBrush(self, QBrush): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setBackgroundBrush(QBrush) """
        pass
    def setBspTreeDepth(self, p_int): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setBspTreeDepth(int) """
        pass
    def setFocus(self, Qt_FocusReason_focusReason=None): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setFocus(Qt.FocusReason focusReason=Qt.OtherFocusReason) """
        pass
    def setFocusItem(self, QGraphicsItem, Qt_FocusReason_focusReason=None): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setFocusItem(QGraphicsItem, Qt.FocusReason focusReason=Qt.OtherFocusReason) """
        pass
    def setFont(self, QFont): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setFont(QFont) """
        pass
    def setForegroundBrush(self, QBrush): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setForegroundBrush(QBrush) """
        pass
    def setItemIndexMethod(self, QGraphicsScene_ItemIndexMethod): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setItemIndexMethod(QGraphicsScene.ItemIndexMethod) """
        pass
    def setPalette(self, QPalette): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setPalette(QPalette) """
        pass
    def setSceneRect(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.setSceneRect(QRectF)
        QGraphicsScene.setSceneRect(float, float, float, float)
        """
        pass
    def setSelectionArea(self, QPainterPath, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.setSelectionArea(QPainterPath, QTransform)
        QGraphicsScene.setSelectionArea(QPainterPath)
        QGraphicsScene.setSelectionArea(QPainterPath, Qt.ItemSelectionMode)
        QGraphicsScene.setSelectionArea(QPainterPath, Qt.ItemSelectionMode, QTransform)
        """
        pass
    def setSortCacheEnabled(self, bool): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setSortCacheEnabled(bool) """
        pass
    def setStickyFocus(self, bool): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setStickyFocus(bool) """
        pass
    def setStyle(self, QStyle): # real signature unknown; restored from __doc__
        """ QGraphicsScene.setStyle(QStyle) """
        pass
    def stickyFocus(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.stickyFocus() -> bool """
        return False
    def style(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.style() -> QStyle """
        return QStyle
    def timerEvent(self, *args, **kwargs): # real signature unknown
        pass
    def update(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QGraphicsScene.update(QRectF rect=QRectF())
        QGraphicsScene.update(float, float, float, float)
        """
        pass
    def views(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.views() -> list-of-QGraphicsView """
        pass
    def wheelEvent(self, QGraphicsSceneWheelEvent): # real signature unknown; restored from __doc__
        """ QGraphicsScene.wheelEvent(QGraphicsSceneWheelEvent) """
        pass
    def width(self): # real signature unknown; restored from __doc__
        """ QGraphicsScene.width() -> float """
        return 0.0
    def __init__(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        pass
    AllLayers = 65535
    BackgroundLayer = 2
    BspTreeIndex = 0
    ForegroundLayer = 4
    ItemLayer = 1
    NoIndex = -1
2.16 QMainWindow.py
# encoding: utf-8
# module PyQt4.QtGui
# from c:\python27\lib\site-packages\PyQt4\QtGui.pyd
# by generator 1.144
# no doc
# imports
import PyQt4.QtCore as __PyQt4_QtCore

from QWidget import QWidget
class QMainWindow(QWidget):
    """ QMainWindow(QWidget parent=None, Qt.WindowFlags flags=0) """
    def actionEvent(self, *args, **kwargs): # real signature unknown
        pass
    def addDockWidget(self, Qt_DockWidgetArea, QDockWidget, Qt_Orientation=None): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QMainWindow.addDockWidget(Qt.DockWidgetArea, QDockWidget)
        QMainWindow.addDockWidget(Qt.DockWidgetArea, QDockWidget, Qt.Orientation)
        """
        pass
    def addToolBar(self, *__args): # real signature unknown; restored from __doc__ with multiple overloads
        """
        QMainWindow.addToolBar(Qt.ToolBarArea, QToolBar)
        QMainWindow.addToolBar(QToolBar)
        QMainWindow.addToolBar(QString) -> QToolBar
        """
        return QToolBar
    def addToolBarBreak(self, Qt_ToolBarArea_area=None): # real signature unknown; restored from __doc__
        """ QMainWindow.addToolBarBreak(Qt.ToolBarArea area=Qt.TopToolBarArea) """
        pass
    def centralWidget(self): # real signature unknown; restored from __doc__
        """ QMainWindow.centralWidget() -> QWidget """
        return QWidget
    def changeEvent(self, *args, **kwargs): # real signature unknown
        pass
    def childEvent(self, *args, **kwargs): # real signature unknown
        pass
    def closeEvent(self, *args, **kwargs): # real signature unknown
        pass
    def connectNotify(self, *args, **kwargs): # real signature unknown
        pass
    def contextMenuEvent(self, QContextMenuEvent): # real signature unknown; restored from __doc__
        """ QMainWindow.contextMenuEvent(QContextMenuEvent) """
        pass
    def corner(self, Qt_Corner): # real signature unknown; restored from __doc__
        """ QMainWindow.corner(Qt.Corner) -> Qt.DockWidgetArea """
        pass
    def create(self, *args, **kwargs): # real signature unknown
        pass
    def createPopupMenu(self): # real signature unknown; restored from __doc__
        """ QMainWindow.createPopupMenu() -> QMenu """
        return QMenu
    def customEvent(self, *args, **kwargs): # real signature unknown
        pass
    def destroy(self, *args, **kwargs): # real signature unknown
        pass
    def disconnectNotify(self, *args, **kwargs): # real signature unknown
        pass
    def dockOptions(self): # real signature unknown; restored from __doc__
        """ QMainWindow.dockOptions() -> QMainWindow.DockOptions """
        pass
    def dockWidgetArea(self, QDockWidget): # real signature unknown; restored from __doc__
        """ QMainWindow.dockWidgetArea(QDockWidget) -> Qt.DockWidgetArea """
        pass
    def documentMode(self): # real signature unknown; restored from __doc__
        """ QMainWindow.documentMode() -> bool """
        return False
    def dragEnterEvent(self, *args, **kwargs): # real signature unknown
        pass
    def dragLeaveEvent(self, *args, **kwargs): # real signature unknown
        pass
    def dragMoveEvent(self, *args, **kwargs): # real signature unknown
        pass
    def dropEvent(self, *args, **kwargs): # real signature unknown
        pass
    def enabledChange(self, *args, **kwargs): # real signature unknown
        pass
    def enterEvent(self, *args, **kwargs): # real signature unknown
        pass
    def event(self, QEvent): # real signature unknown; restored from __doc__
        """ QMainWindow.event(QEvent) -> bool """
        return False
    def focusInEvent(self, *args, **kwargs): # real signature unknown
        pass
    def focusNextChild(self, *args, **kwargs): # real signature unknown
        pass
    def focusNextPrevChild(self, *args, **kwargs): # real signature unknown
        pass
    def focusOutEvent(self, *args, **kwargs): # real signature unknown
        pass
    def focusPreviousChild(self, *args, **kwargs): # real signature unknown
        pass
    def fontChange(self, *args, **kwargs): # real signature unknown
        pass
    def hideEvent(self, *args, **kwargs): # real signature unknown
        pass
    def iconSize(self): # real signature unknown; restored from __doc__
        """ QMainWindow.iconSize() -> QSize """
        pass
    def iconSizeChanged(self, *args, **kwargs): # real signature unknown
        """ QMainWindow.iconSizeChanged[QSize] [signal] """
        pass
    def inputMethodEvent(self, *args, **kwargs): # real signature unknown
        pass
    def insertToolBar(self, QToolBar, QToolBar_1): # real signature unknown; restored from __doc__
        """ QMainWindow.insertToolBar(QToolBar, QToolBar) """
        pass
    def insertToolBarBreak(self, QToolBar): # real signature unknown; restored from __doc__
        """ QMainWindow.insertToolBarBreak(QToolBar) """
        pass
    def isAnimated(self): # real signature unknown; restored from __doc__
        """ QMainWindow.isAnimated() -> bool """
        return False
    def isDockNestingEnabled(self): # real signature unknown; restored from __doc__
        """ QMainWindow.isDockNestingEnabled() -> bool """
        return False
    def isSeparator(self, QPoint): # real signature unknown; restored from __doc__
        """ QMainWindow.isSeparator(QPoint) -> bool """
        return False
    def keyPressEvent(self, *args, **kwargs): # real signature unknown
        pass
    def keyReleaseEvent(self, *args, **kwargs): # real signature unknown
        pass
    def languageChange(self, *args, **kwargs): # real signature unknown
        pass
    def leaveEvent(self, *args, **kwargs): # real signature unknown
        pass
    def menuBar(self): # real signature unknown; restored from __doc__
        """ QMainWindow.menuBar() -> QMenuBar """
        return QMenuBar
    def menuWidget(self): # real signature unknown; restored from __doc__
        """ QMainWindow.menuWidget() -> QWidget """
        return QWidget
    def metric(self, *args, **kwargs): # real signature unknown
        pass
    def mouseDoubleClickEvent(self, *args, **kwargs): # real signature unknown
        pass
    def mouseMoveEvent(self, *args, **kwargs): # real signature unknown
        pass
    def mousePressEvent(self, *args, **kwargs): # real signature unknown
        pass
    def mouseReleaseEvent(self, *args, **kwargs): # real signature unknown
        pass
    def moveEvent(self, *args, **kwargs): # real signature unknown
        pass
    def paintEvent(self, *args, **kwargs): # real signature unknown
        pass
    def paletteChange(self, *args, **kwargs): # real signature unknown
        pass
    def receivers(self, *args, **kwargs): # real signature unknown
        pass
    def removeDockWidget(self, QDockWidget): # real signature unknown; restored from __doc__
        """ QMainWindow.removeDockWidget(QDockWidget) """
        pass
    def removeToolBar(self, QToolBar): # real signature unknown; restored from __doc__
        """ QMainWindow.removeToolBar(QToolBar) """
        pass
    def removeToolBarBreak(self, QToolBar): # real signature unknown; restored from __doc__
        """ QMainWindow.removeToolBarBreak(QToolBar) """
        pass
    def resetInputContext(self, *args, **kwargs): # real signature unknown
        pass
    def resizeEvent(self, *args, **kwargs): # real signature unknown
        pass
    def restoreDockWidget(self, QDockWidget): # real signature unknown; restored from __doc__
        """ QMainWindow.restoreDockWidget(QDockWidget) -> bool """
        return False
    def restoreState(self, QByteArray, int_version=0): # real signature unknown; restored from __doc__
        """ QMainWindow.restoreState(QByteArray, int version=0) -> bool """
        return False
    def saveState(self, int_version=0): # real signature unknown; restored from __doc__
        """ QMainWindow.saveState(int version=0) -> QByteArray """
        pass
    def sender(self, *args, **kwargs): # real signature unknown
        pass
    def senderSignalIndex(self, *args, **kwargs): # real signature unknown
        pass
    def setAnimated(self, bool): # real signature unknown; restored from __doc__
        """ QMainWindow.setAnimated(bool) """
        pass
    def setCentralWidget(self, QWidget): # real signature unknown; restored from __doc__
        """ QMainWindow.setCentralWidget(QWidget) """
        pass
    def setCorner(self, Qt_Corner, Qt_DockWidgetArea): # real signature unknown; restored from __doc__
        """ QMainWindow.setCorner(Qt.Corner, Qt.DockWidgetArea) """
        pass
    def setDockNestingEnabled(self, bool): # real signature unknown; restored from __doc__
        """ QMainWindow.setDockNestingEnabled(bool) """
        pass
    def setDockOptions(self, QMainWindow_DockOptions): # real signature unknown; restored from __doc__
        """ QMainWindow.setDockOptions(QMainWindow.DockOptions) """
        pass
    def setDocumentMode(self, bool): # real signature unknown; restored from __doc__
        """ QMainWindow.setDocumentMode(bool) """
        pass
    def setIconSize(self, QSize): # real signature unknown; restored from __doc__
        """ QMainWindow.setIconSize(QSize) """
        pass
    def setMenuBar(self, QMenuBar): # real signature unknown; restored from __doc__
        """ QMainWindow.setMenuBar(QMenuBar) """
        pass
    def setMenuWidget(self, QWidget): # real signature unknown; restored from __doc__
        """ QMainWindow.setMenuWidget(QWidget) """
        pass
    def setStatusBar(self, QStatusBar): # real signature unknown; restored from __doc__
        """ QMainWindow.setStatusBar(QStatusBar) """
        pass
    def setTabPosition(self, Qt_DockWidgetAreas, QTabWidget_TabPosition): # real signature unknown; restored from __doc__
        """ QMainWindow.setTabPosition(Qt.DockWidgetAreas, QTabWidget.TabPosition) """
        pass
    def setTabShape(self, QTabWidget_TabShape): # real signature unknown; restored from __doc__
        """ QMainWindow.setTabShape(QTabWidget.TabShape) """
        pass
    def setToolButtonStyle(self, Qt_ToolButtonStyle): # real signature unknown; restored from __doc__
        """ QMainWindow.setToolButtonStyle(Qt.ToolButtonStyle) """
        pass
    def setUnifiedTitleAndToolBarOnMac(self, bool): # real signature unknown; restored from __doc__
        """ QMainWindow.setUnifiedTitleAndToolBarOnMac(bool) """
        pass
    def showEvent(self, *args, **kwargs): # real signature unknown
        pass
    def splitDockWidget(self, QDockWidget, QDockWidget_1, Qt_Orientation): # real signature unknown; restored from __doc__
        """ QMainWindow.splitDockWidget(QDockWidget, QDockWidget, Qt.Orientation) """
        pass
    def statusBar(self): # real signature unknown; restored from __doc__
        """ QMainWindow.statusBar() -> QStatusBar """
        return QStatusBar
    def tabifiedDockWidgets(self, QDockWidget): # real signature unknown; restored from __doc__
        """ QMainWindow.tabifiedDockWidgets(QDockWidget) -> list-of-QDockWidget """
        pass
    def tabifyDockWidget(self, QDockWidget, QDockWidget_1): # real signature unknown; restored from __doc__
        """ QMainWindow.tabifyDockWidget(QDockWidget, QDockWidget) """
        pass
    def tabletEvent(self, *args, **kwargs): # real signature unknown
        pass
    def tabPosition(self, Qt_DockWidgetArea): # real signature unknown; restored from __doc__
        """ QMainWindow.tabPosition(Qt.DockWidgetArea) -> QTabWidget.TabPosition """
        pass
    def tabShape(self): # real signature unknown; restored from __doc__
        """ QMainWindow.tabShape() -> QTabWidget.TabShape """
        pass
    def timerEvent(self, *args, **kwargs): # real signature unknown
        pass
    def toolBarArea(self, QToolBar): # real signature unknown; restored from __doc__
        """ QMainWindow.toolBarArea(QToolBar) -> Qt.ToolBarArea """
        pass
    def toolBarBreak(self, QToolBar): # real signature unknown; restored from __doc__
        """ QMainWindow.toolBarBreak(QToolBar) -> bool """
        return False
    def toolButtonStyle(self): # real signature unknown; restored from __doc__
        """ QMainWindow.toolButtonStyle() -> Qt.ToolButtonStyle """
        pass
    def toolButtonStyleChanged(self, *args, **kwargs): # real signature unknown
        """ QMainWindow.toolButtonStyleChanged[Qt.ToolButtonStyle] [signal] """
        pass
    def unifiedTitleAndToolBarOnMac(self): # real signature unknown; restored from __doc__
        """ QMainWindow.unifiedTitleAndToolBarOnMac() -> bool """
        return False
    def updateMicroFocus(self, *args, **kwargs): # real signature unknown
        pass
    def wheelEvent(self, *args, **kwargs): # real signature unknown
        pass
    def windowActivationChange(self, *args, **kwargs): # real signature unknown
        pass
    def winEvent(self, *args, **kwargs): # real signature unknown
        pass
    def __init__(self, QWidget_parent=None, Qt_WindowFlags_flags=0): # real signature unknown; restored from __doc__
        pass
    AllowNestedDocks = 2
    AllowTabbedDocks = 4
    AnimatedDocks = 1
    ForceTabbedDocks = 8
    VerticalTabs = 16

